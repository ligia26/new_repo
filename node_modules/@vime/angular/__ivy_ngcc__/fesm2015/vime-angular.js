import { VmAudio, VmFile, VmCaptionControl, VmControl, VmIcon, VmTooltip, VmCaptions, VmClickToPlay, VmControlGroup, VmControlSpacer, VmControls, VmCurrentTime, VmTime, VmDailymotion, VmEmbed, VmDash, VmVideo, VmDblClickFullscreen, VmDefaultControls, VmEndTime, VmFullscreenControl, VmLiveIndicator, VmMuteControl, VmPipControl, VmPlaybackControl, VmScrim, VmScrubberControl, VmSlider, VmSettingsControl, VmTimeProgress, VmVolumeControl, VmDefaultSettings, VmMenu, VmMenuItem, VmMenuRadio, VmMenuRadioGroup, VmSettings, VmSubmenu, VmDefaultUi, VmLoadingScreen, VmPoster, VmSpinner, VmUi, VmHls, VmIconLibrary, VmPlayer, VmSkeleton, VmVimeo, VmYoutube, findPlayer, createDispatcher, usePlayerContext } from '@vime/core';
import * as ɵngcc0 from '@angular/core';

const _c0 = ["*"];
export { MediaType, Provider, ViewType, watchComponentRegistry } from '@vime/core';
import { __decorate, __awaiter } from 'tslib';
import { EventEmitter, Component, ChangeDetectionStrategy, ChangeDetectorRef, ElementRef, NgZone, Injectable, NgModule } from '@angular/core';

/* eslint-disable */
const define = (tagName, clazz) => {
    const isClient = typeof window !== 'undefined';
    if (isClient && !customElements.get(tagName))
        customElements.define(tagName, clazz);
};
const proxyInputs = (Component, inputs) => {
    const Prototype = Component.prototype;
    inputs.forEach(input => {
        Object.defineProperty(Prototype, input, {
            get() {
                return this.el[input];
            },
            set(val) {
                this.z.runOutsideAngular(() => (this.el[input] = val));
            },
        });
    });
};
const proxyMethods = (Component, methods) => {
    const Prototype = Component.prototype;
    methods.forEach(methodName => {
        Prototype[methodName] = function () {
            const args = arguments;
            return this.z.runOutsideAngular(() => this.el[methodName].apply(this.el, args));
        };
    });
};
const initOutputs = (instance, events) => {
    events.forEach(eventName => (instance[eventName] = new EventEmitter()));
};
function ProxyCmp(opts) {
    return function (Component) {
        if (opts.inputs)
            proxyInputs(Component, opts.inputs);
        if (opts.methods)
            proxyMethods(Component, opts.methods);
        return Component;
    };
}

const AudioInputs = [
    'willAttach',
    'crossOrigin',
    'preload',
    'disableRemotePlayback',
    'mediaTitle',
];
const AudioMethods = [
    'getAdapter',
];
const AudioOutputs = [];
let Audio = class Audio {
    constructor(c, r, z) {
        this.z = z;
        define('vm-audio', VmAudio);
        define('vm-file', VmFile);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
Audio.ɵfac = function Audio_Factory(t) { return new (t || Audio)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
Audio.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: Audio, selectors: [["vm-audio"]], inputs: { willAttach: "willAttach", crossOrigin: "crossOrigin", preload: "preload", disableRemotePlayback: "disableRemotePlayback", mediaTitle: "mediaTitle" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function Audio_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
Audio.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Audio = __decorate([
    ProxyCmp({
        inputs: AudioInputs,
        methods: AudioMethods,
    })
], Audio);

const CaptionControlInputs = [
    'showIcon',
    'hideIcon',
    'tooltipPosition',
    'tooltipDirection',
    'hideTooltip',
    'icons',
    'keys',
    'i18n',
    'playbackReady',
    'textTracks',
    'isTextTrackVisible',
];
const CaptionControlMethods = [];
const CaptionControlOutputs = [];
let CaptionControl = class CaptionControl {
    constructor(c, r, z) {
        this.z = z;
        define('vm-caption-control', VmCaptionControl);
        define('vm-control', VmControl);
        define('vm-icon', VmIcon);
        define('vm-tooltip', VmTooltip);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
CaptionControl.ɵfac = function CaptionControl_Factory(t) { return new (t || CaptionControl)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
CaptionControl.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CaptionControl, selectors: [["vm-caption-control"]], inputs: { showIcon: "showIcon", hideIcon: "hideIcon", tooltipPosition: "tooltipPosition", tooltipDirection: "tooltipDirection", hideTooltip: "hideTooltip", icons: "icons", keys: "keys", i18n: "i18n", playbackReady: "playbackReady", textTracks: "textTracks", isTextTrackVisible: "isTextTrackVisible" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function CaptionControl_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
CaptionControl.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
CaptionControl = __decorate([
    ProxyCmp({
        inputs: CaptionControlInputs,
        methods: CaptionControlMethods,
    })
], CaptionControl);

const CaptionsInputs = [
    'hidden',
    'isControlsActive',
    'isVideoView',
    'playbackStarted',
    'textTracks',
    'currentTextTrack',
    'isTextTrackVisible',
];
const CaptionsMethods = [];
const CaptionsOutputs = [];
let Captions = class Captions {
    constructor(c, r, z) {
        this.z = z;
        define('vm-captions', VmCaptions);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
Captions.ɵfac = function Captions_Factory(t) { return new (t || Captions)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
Captions.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: Captions, selectors: [["vm-captions"]], inputs: { hidden: "hidden", isControlsActive: "isControlsActive", isVideoView: "isVideoView", playbackStarted: "playbackStarted", textTracks: "textTracks", currentTextTrack: "currentTextTrack", isTextTrackVisible: "isTextTrackVisible" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function Captions_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
Captions.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Captions = __decorate([
    ProxyCmp({
        inputs: CaptionsInputs,
        methods: CaptionsMethods,
    })
], Captions);

const ClickToPlayInputs = [
    'useOnMobile',
    'paused',
    'isVideoView',
    'isMobile',
];
const ClickToPlayMethods = [
    'forceClick',
];
const ClickToPlayOutputs = [];
let ClickToPlay = class ClickToPlay {
    constructor(c, r, z) {
        this.z = z;
        define('vm-click-to-play', VmClickToPlay);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
ClickToPlay.ɵfac = function ClickToPlay_Factory(t) { return new (t || ClickToPlay)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
ClickToPlay.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ClickToPlay, selectors: [["vm-click-to-play"]], inputs: { useOnMobile: "useOnMobile", paused: "paused", isVideoView: "isVideoView", isMobile: "isMobile" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function ClickToPlay_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
ClickToPlay.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
ClickToPlay = __decorate([
    ProxyCmp({
        inputs: ClickToPlayInputs,
        methods: ClickToPlayMethods,
    })
], ClickToPlay);

const ControlInputs = [
    'keys',
    'identifier',
    'hidden',
    'label',
    'menu',
    'expanded',
    'pressed',
    'isTouch',
];
const ControlMethods = [
    'focusControl',
    'blurControl',
];
const ControlOutputs = [
    'vmInteractionChange',
    'vmFocus',
    'vmBlur',
];
let Control = class Control {
    constructor(c, r, z) {
        this.z = z;
        define('vm-control', VmControl);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmInteractionChange', 'vmFocus', 'vmBlur']);
    }
};
Control.ɵfac = function Control_Factory(t) { return new (t || Control)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
Control.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: Control, selectors: [["vm-control"]], inputs: { keys: "keys", identifier: "identifier", hidden: "hidden", label: "label", menu: "menu", expanded: "expanded", pressed: "pressed", isTouch: "isTouch" }, outputs: { vmInteractionChange: "vmInteractionChange", vmFocus: "vmFocus", vmBlur: "vmBlur" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function Control_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
Control.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Control = __decorate([
    ProxyCmp({
        inputs: ControlInputs,
        methods: ControlMethods,
    })
], Control);

const ControlGroupInputs = [
    'space',
];
const ControlGroupMethods = [];
const ControlGroupOutputs = [];
let ControlGroup = class ControlGroup {
    constructor(c, r, z) {
        this.z = z;
        define('vm-control-group', VmControlGroup);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
ControlGroup.ɵfac = function ControlGroup_Factory(t) { return new (t || ControlGroup)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
ControlGroup.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ControlGroup, selectors: [["vm-control-group"]], inputs: { space: "space" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function ControlGroup_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
ControlGroup.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
ControlGroup = __decorate([
    ProxyCmp({
        inputs: ControlGroupInputs,
        methods: ControlGroupMethods,
    })
], ControlGroup);

const ControlSpacerInputs = [];
const ControlSpacerMethods = [];
const ControlSpacerOutputs = [];
let ControlSpacer = class ControlSpacer {
    constructor(c, r, z) {
        this.z = z;
        define('vm-control-spacer', VmControlSpacer);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
ControlSpacer.ɵfac = function ControlSpacer_Factory(t) { return new (t || ControlSpacer)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
ControlSpacer.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ControlSpacer, selectors: [["vm-control-spacer"]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function ControlSpacer_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
ControlSpacer.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
ControlSpacer = __decorate([
    ProxyCmp({
        inputs: ControlSpacerInputs,
        methods: ControlSpacerMethods,
    })
], ControlSpacer);

const ControlsInputs = [
    'hidden',
    'fullWidth',
    'fullHeight',
    'direction',
    'align',
    'justify',
    'pin',
    'activeDuration',
    'waitForPlaybackStart',
    'hideWhenPaused',
    'hideOnMouseLeave',
    'isAudioView',
    'isSettingsActive',
    'playbackReady',
    'isControlsActive',
    'paused',
    'playbackStarted',
];
const ControlsMethods = [];
const ControlsOutputs = [];
let Controls = class Controls {
    constructor(c, r, z) {
        this.z = z;
        define('vm-controls', VmControls);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
Controls.ɵfac = function Controls_Factory(t) { return new (t || Controls)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
Controls.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: Controls, selectors: [["vm-controls"]], inputs: { hidden: "hidden", fullWidth: "fullWidth", fullHeight: "fullHeight", direction: "direction", align: "align", justify: "justify", pin: "pin", activeDuration: "activeDuration", waitForPlaybackStart: "waitForPlaybackStart", hideWhenPaused: "hideWhenPaused", hideOnMouseLeave: "hideOnMouseLeave", isAudioView: "isAudioView", isSettingsActive: "isSettingsActive", playbackReady: "playbackReady", isControlsActive: "isControlsActive", paused: "paused", playbackStarted: "playbackStarted" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function Controls_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
Controls.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Controls = __decorate([
    ProxyCmp({
        inputs: ControlsInputs,
        methods: ControlsMethods,
    })
], Controls);

const CurrentTimeInputs = [
    'currentTime',
    'i18n',
    'alwaysShowHours',
];
const CurrentTimeMethods = [];
const CurrentTimeOutputs = [];
let CurrentTime = class CurrentTime {
    constructor(c, r, z) {
        this.z = z;
        define('vm-current-time', VmCurrentTime);
        define('vm-time', VmTime);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
CurrentTime.ɵfac = function CurrentTime_Factory(t) { return new (t || CurrentTime)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
CurrentTime.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: CurrentTime, selectors: [["vm-current-time"]], inputs: { currentTime: "currentTime", i18n: "i18n", alwaysShowHours: "alwaysShowHours" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function CurrentTime_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
CurrentTime.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
CurrentTime = __decorate([
    ProxyCmp({
        inputs: CurrentTimeInputs,
        methods: CurrentTimeMethods,
    })
], CurrentTime);

const DailymotionInputs = [
    'videoId',
    'shouldAutoplayQueue',
    'showUpNextQueue',
    'showShareButtons',
    'color',
    'syndication',
    'showDailymotionLogo',
    'showVideoInfo',
    'language',
    'autoplay',
    'controls',
    'poster',
    'logger',
    'loop',
    'muted',
    'playsinline',
];
const DailymotionMethods = [
    'getAdapter',
];
const DailymotionOutputs = [
    'vmError',
];
let Dailymotion = class Dailymotion {
    constructor(c, r, z) {
        this.z = z;
        define('vm-dailymotion', VmDailymotion);
        define('vm-embed', VmEmbed);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmError']);
    }
};
Dailymotion.ɵfac = function Dailymotion_Factory(t) { return new (t || Dailymotion)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
Dailymotion.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: Dailymotion, selectors: [["vm-dailymotion"]], inputs: { videoId: "videoId", shouldAutoplayQueue: "shouldAutoplayQueue", showUpNextQueue: "showUpNextQueue", showShareButtons: "showShareButtons", color: "color", syndication: "syndication", showDailymotionLogo: "showDailymotionLogo", showVideoInfo: "showVideoInfo", language: "language", autoplay: "autoplay", controls: "controls", poster: "poster", logger: "logger", loop: "loop", muted: "muted", playsinline: "playsinline" }, outputs: { vmError: "vmError" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function Dailymotion_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
Dailymotion.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Dailymotion = __decorate([
    ProxyCmp({
        inputs: DailymotionInputs,
        methods: DailymotionMethods,
    })
], Dailymotion);

const DashInputs = [
    'src',
    'version',
    'libSrc',
    'config',
    'autoplay',
    'crossOrigin',
    'preload',
    'poster',
    'controlsList',
    'autoPiP',
    'disablePiP',
    'disableRemotePlayback',
    'mediaTitle',
    'enableTextTracksByDefault',
    'shouldRenderNativeTextTracks',
    'isTextTrackVisible',
    'currentTextTrack',
];
const DashMethods = [
    'getAdapter',
];
const DashOutputs = [
    'vmError',
];
let Dash = class Dash {
    constructor(c, r, z) {
        this.z = z;
        define('vm-dash', VmDash);
        define('vm-file', VmFile);
        define('vm-video', VmVideo);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmError']);
    }
};
Dash.ɵfac = function Dash_Factory(t) { return new (t || Dash)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
Dash.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: Dash, selectors: [["vm-dash"]], inputs: { src: "src", version: "version", libSrc: "libSrc", config: "config", autoplay: "autoplay", crossOrigin: "crossOrigin", preload: "preload", poster: "poster", controlsList: "controlsList", autoPiP: "autoPiP", disablePiP: "disablePiP", disableRemotePlayback: "disableRemotePlayback", mediaTitle: "mediaTitle", enableTextTracksByDefault: "enableTextTracksByDefault", shouldRenderNativeTextTracks: "shouldRenderNativeTextTracks", isTextTrackVisible: "isTextTrackVisible", currentTextTrack: "currentTextTrack" }, outputs: { vmError: "vmError" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function Dash_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
Dash.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Dash = __decorate([
    ProxyCmp({
        inputs: DashInputs,
        methods: DashMethods,
    })
], Dash);

const DblClickFullscreenInputs = [
    'useOnMobile',
    'isFullscreenActive',
    'isVideoView',
    'playbackReady',
    'isMobile',
];
const DblClickFullscreenMethods = [];
const DblClickFullscreenOutputs = [];
let DblClickFullscreen = class DblClickFullscreen {
    constructor(c, r, z) {
        this.z = z;
        define('vm-dbl-click-fullscreen', VmDblClickFullscreen);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
DblClickFullscreen.ɵfac = function DblClickFullscreen_Factory(t) { return new (t || DblClickFullscreen)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
DblClickFullscreen.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: DblClickFullscreen, selectors: [["vm-dbl-click-fullscreen"]], inputs: { useOnMobile: "useOnMobile", isFullscreenActive: "isFullscreenActive", isVideoView: "isVideoView", playbackReady: "playbackReady", isMobile: "isMobile" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function DblClickFullscreen_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
DblClickFullscreen.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
DblClickFullscreen = __decorate([
    ProxyCmp({
        inputs: DblClickFullscreenInputs,
        methods: DblClickFullscreenMethods,
    })
], DblClickFullscreen);

const DefaultControlsInputs = [
    'activeDuration',
    'waitForPlaybackStart',
    'hideWhenPaused',
    'hideOnMouseLeave',
    'theme',
    'isMobile',
    'isLive',
    'isAudioView',
    'isVideoView',
];
const DefaultControlsMethods = [];
const DefaultControlsOutputs = [];
let DefaultControls = class DefaultControls {
    constructor(c, r, z) {
        this.z = z;
        define('vm-default-controls', VmDefaultControls);
        define('vm-caption-control', VmCaptionControl);
        define('vm-control', VmControl);
        define('vm-icon', VmIcon);
        define('vm-tooltip', VmTooltip);
        define('vm-control-group', VmControlGroup);
        define('vm-control-spacer', VmControlSpacer);
        define('vm-controls', VmControls);
        define('vm-current-time', VmCurrentTime);
        define('vm-time', VmTime);
        define('vm-end-time', VmEndTime);
        define('vm-fullscreen-control', VmFullscreenControl);
        define('vm-live-indicator', VmLiveIndicator);
        define('vm-mute-control', VmMuteControl);
        define('vm-pip-control', VmPipControl);
        define('vm-playback-control', VmPlaybackControl);
        define('vm-scrim', VmScrim);
        define('vm-scrubber-control', VmScrubberControl);
        define('vm-slider', VmSlider);
        define('vm-settings-control', VmSettingsControl);
        define('vm-time-progress', VmTimeProgress);
        define('vm-volume-control', VmVolumeControl);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
DefaultControls.ɵfac = function DefaultControls_Factory(t) { return new (t || DefaultControls)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
DefaultControls.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: DefaultControls, selectors: [["vm-default-controls"]], inputs: { activeDuration: "activeDuration", waitForPlaybackStart: "waitForPlaybackStart", hideWhenPaused: "hideWhenPaused", hideOnMouseLeave: "hideOnMouseLeave", theme: "theme", isMobile: "isMobile", isLive: "isLive", isAudioView: "isAudioView", isVideoView: "isVideoView" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function DefaultControls_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
DefaultControls.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
DefaultControls = __decorate([
    ProxyCmp({
        inputs: DefaultControlsInputs,
        methods: DefaultControlsMethods,
    })
], DefaultControls);

const DefaultSettingsInputs = [
    'pin',
    'i18n',
    'playbackReady',
    'playbackRate',
    'playbackRates',
    'isVideoView',
    'playbackQuality',
    'playbackQualities',
    'textTracks',
    'currentTextTrack',
    'audioTracks',
    'currentAudioTrack',
    'isTextTrackVisible',
];
const DefaultSettingsMethods = [];
const DefaultSettingsOutputs = [];
let DefaultSettings = class DefaultSettings {
    constructor(c, r, z) {
        this.z = z;
        define('vm-default-settings', VmDefaultSettings);
        define('vm-icon', VmIcon);
        define('vm-menu', VmMenu);
        define('vm-menu-item', VmMenuItem);
        define('vm-menu-radio', VmMenuRadio);
        define('vm-menu-radio-group', VmMenuRadioGroup);
        define('vm-settings', VmSettings);
        define('vm-submenu', VmSubmenu);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
DefaultSettings.ɵfac = function DefaultSettings_Factory(t) { return new (t || DefaultSettings)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
DefaultSettings.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: DefaultSettings, selectors: [["vm-default-settings"]], inputs: { pin: "pin", i18n: "i18n", playbackReady: "playbackReady", playbackRate: "playbackRate", playbackRates: "playbackRates", isVideoView: "isVideoView", playbackQuality: "playbackQuality", playbackQualities: "playbackQualities", textTracks: "textTracks", currentTextTrack: "currentTextTrack", audioTracks: "audioTracks", currentAudioTrack: "currentAudioTrack", isTextTrackVisible: "isTextTrackVisible" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function DefaultSettings_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
DefaultSettings.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
DefaultSettings = __decorate([
    ProxyCmp({
        inputs: DefaultSettingsInputs,
        methods: DefaultSettingsMethods,
    })
], DefaultSettings);

const DefaultUiInputs = [
    'noClickToPlay',
    'noDblClickFullscreen',
    'noCaptions',
    'noPoster',
    'noSpinner',
    'noControls',
    'noSettings',
    'noLoadingScreen',
];
const DefaultUiMethods = [];
const DefaultUiOutputs = [];
let DefaultUi = class DefaultUi {
    constructor(c, r, z) {
        this.z = z;
        define('vm-default-ui', VmDefaultUi);
        define('vm-caption-control', VmCaptionControl);
        define('vm-control', VmControl);
        define('vm-icon', VmIcon);
        define('vm-tooltip', VmTooltip);
        define('vm-captions', VmCaptions);
        define('vm-click-to-play', VmClickToPlay);
        define('vm-control-group', VmControlGroup);
        define('vm-control-spacer', VmControlSpacer);
        define('vm-controls', VmControls);
        define('vm-current-time', VmCurrentTime);
        define('vm-time', VmTime);
        define('vm-dbl-click-fullscreen', VmDblClickFullscreen);
        define('vm-default-controls', VmDefaultControls);
        define('vm-end-time', VmEndTime);
        define('vm-fullscreen-control', VmFullscreenControl);
        define('vm-live-indicator', VmLiveIndicator);
        define('vm-mute-control', VmMuteControl);
        define('vm-pip-control', VmPipControl);
        define('vm-playback-control', VmPlaybackControl);
        define('vm-scrim', VmScrim);
        define('vm-scrubber-control', VmScrubberControl);
        define('vm-slider', VmSlider);
        define('vm-settings-control', VmSettingsControl);
        define('vm-time-progress', VmTimeProgress);
        define('vm-volume-control', VmVolumeControl);
        define('vm-default-settings', VmDefaultSettings);
        define('vm-menu', VmMenu);
        define('vm-menu-item', VmMenuItem);
        define('vm-menu-radio', VmMenuRadio);
        define('vm-menu-radio-group', VmMenuRadioGroup);
        define('vm-settings', VmSettings);
        define('vm-submenu', VmSubmenu);
        define('vm-loading-screen', VmLoadingScreen);
        define('vm-poster', VmPoster);
        define('vm-spinner', VmSpinner);
        define('vm-ui', VmUi);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
DefaultUi.ɵfac = function DefaultUi_Factory(t) { return new (t || DefaultUi)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
DefaultUi.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: DefaultUi, selectors: [["vm-default-ui"]], inputs: { noClickToPlay: "noClickToPlay", noDblClickFullscreen: "noDblClickFullscreen", noCaptions: "noCaptions", noPoster: "noPoster", noSpinner: "noSpinner", noControls: "noControls", noSettings: "noSettings", noLoadingScreen: "noLoadingScreen" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function DefaultUi_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
DefaultUi.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
DefaultUi = __decorate([
    ProxyCmp({
        inputs: DefaultUiInputs,
        methods: DefaultUiMethods,
    })
], DefaultUi);

const EmbedInputs = [
    'embedSrc',
    'mediaTitle',
    'params',
    'origin',
    'preconnections',
    'decoder',
];
const EmbedMethods = [
    'postMessage',
];
const EmbedOutputs = [
    'vmEmbedSrcChange',
    'vmEmbedMessage',
    'vmEmbedLoaded',
];
let Embed = class Embed {
    constructor(c, r, z) {
        this.z = z;
        define('vm-embed', VmEmbed);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmEmbedSrcChange', 'vmEmbedMessage', 'vmEmbedLoaded']);
    }
};
Embed.ɵfac = function Embed_Factory(t) { return new (t || Embed)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
Embed.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: Embed, selectors: [["vm-embed"]], inputs: { embedSrc: "embedSrc", mediaTitle: "mediaTitle", params: "params", origin: "origin", preconnections: "preconnections", decoder: "decoder" }, outputs: { vmEmbedSrcChange: "vmEmbedSrcChange", vmEmbedMessage: "vmEmbedMessage", vmEmbedLoaded: "vmEmbedLoaded" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function Embed_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
Embed.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Embed = __decorate([
    ProxyCmp({
        inputs: EmbedInputs,
        methods: EmbedMethods,
    })
], Embed);

const EndTimeInputs = [
    'duration',
    'i18n',
    'alwaysShowHours',
];
const EndTimeMethods = [];
const EndTimeOutputs = [];
let EndTime = class EndTime {
    constructor(c, r, z) {
        this.z = z;
        define('vm-end-time', VmEndTime);
        define('vm-time', VmTime);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
EndTime.ɵfac = function EndTime_Factory(t) { return new (t || EndTime)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
EndTime.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: EndTime, selectors: [["vm-end-time"]], inputs: { duration: "duration", i18n: "i18n", alwaysShowHours: "alwaysShowHours" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function EndTime_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
EndTime.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
EndTime = __decorate([
    ProxyCmp({
        inputs: EndTimeInputs,
        methods: EndTimeMethods,
    })
], EndTime);

const FileInputs = [
    'willAttach',
    'crossOrigin',
    'preload',
    'poster',
    'mediaTitle',
    'controlsList',
    'autoPiP',
    'disablePiP',
    'disableRemotePlayback',
    'viewType',
    'playbackRates',
    'language',
    'autoplay',
    'controls',
    'logger',
    'loop',
    'muted',
    'playsinline',
    'noConnect',
    'paused',
    'currentTime',
    'volume',
    'playbackReady',
    'playbackStarted',
    'currentTextTrack',
    'hasCustomTextManager',
    'isTextTrackVisible',
    'shouldRenderNativeTextTracks',
];
const FileMethods = [
    'getAdapter',
];
const FileOutputs = [
    'vmError',
    'vmMediaElChange',
    'vmSrcSetChange',
];
let File = class File {
    constructor(c, r, z) {
        this.z = z;
        define('vm-file', VmFile);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmError', 'vmMediaElChange', 'vmSrcSetChange']);
    }
};
File.ɵfac = function File_Factory(t) { return new (t || File)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
File.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: File, selectors: [["vm-file"]], inputs: { willAttach: "willAttach", crossOrigin: "crossOrigin", preload: "preload", poster: "poster", mediaTitle: "mediaTitle", controlsList: "controlsList", autoPiP: "autoPiP", disablePiP: "disablePiP", disableRemotePlayback: "disableRemotePlayback", viewType: "viewType", playbackRates: "playbackRates", language: "language", autoplay: "autoplay", controls: "controls", logger: "logger", loop: "loop", muted: "muted", playsinline: "playsinline", noConnect: "noConnect", paused: "paused", currentTime: "currentTime", volume: "volume", playbackReady: "playbackReady", playbackStarted: "playbackStarted", currentTextTrack: "currentTextTrack", hasCustomTextManager: "hasCustomTextManager", isTextTrackVisible: "isTextTrackVisible", shouldRenderNativeTextTracks: "shouldRenderNativeTextTracks" }, outputs: { vmError: "vmError", vmMediaElChange: "vmMediaElChange", vmSrcSetChange: "vmSrcSetChange" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function File_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
File.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
File = __decorate([
    ProxyCmp({
        inputs: FileInputs,
        methods: FileMethods,
    })
], File);

const FullscreenControlInputs = [
    'enterIcon',
    'exitIcon',
    'icons',
    'tooltipPosition',
    'tooltipDirection',
    'hideTooltip',
    'keys',
    'isFullscreenActive',
    'i18n',
    'playbackReady',
];
const FullscreenControlMethods = [];
const FullscreenControlOutputs = [];
let FullscreenControl = class FullscreenControl {
    constructor(c, r, z) {
        this.z = z;
        define('vm-fullscreen-control', VmFullscreenControl);
        define('vm-control', VmControl);
        define('vm-icon', VmIcon);
        define('vm-tooltip', VmTooltip);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
FullscreenControl.ɵfac = function FullscreenControl_Factory(t) { return new (t || FullscreenControl)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
FullscreenControl.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: FullscreenControl, selectors: [["vm-fullscreen-control"]], inputs: { enterIcon: "enterIcon", exitIcon: "exitIcon", icons: "icons", tooltipPosition: "tooltipPosition", tooltipDirection: "tooltipDirection", hideTooltip: "hideTooltip", keys: "keys", isFullscreenActive: "isFullscreenActive", i18n: "i18n", playbackReady: "playbackReady" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function FullscreenControl_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
FullscreenControl.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
FullscreenControl = __decorate([
    ProxyCmp({
        inputs: FullscreenControlInputs,
        methods: FullscreenControlMethods,
    })
], FullscreenControl);

const HlsInputs = [
    'version',
    'libSrc',
    'config',
    'crossOrigin',
    'preload',
    'poster',
    'controlsList',
    'autoPiP',
    'disablePiP',
    'disableRemotePlayback',
    'playbackReady',
    'mediaTitle',
];
const HlsMethods = [
    'getAdapter',
];
const HlsOutputs = [
    'vmError',
];
let Hls = class Hls {
    constructor(c, r, z) {
        this.z = z;
        define('vm-hls', VmHls);
        define('vm-file', VmFile);
        define('vm-video', VmVideo);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmError']);
    }
};
Hls.ɵfac = function Hls_Factory(t) { return new (t || Hls)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
Hls.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: Hls, selectors: [["vm-hls"]], inputs: { version: "version", libSrc: "libSrc", config: "config", crossOrigin: "crossOrigin", preload: "preload", poster: "poster", controlsList: "controlsList", autoPiP: "autoPiP", disablePiP: "disablePiP", disableRemotePlayback: "disableRemotePlayback", playbackReady: "playbackReady", mediaTitle: "mediaTitle" }, outputs: { vmError: "vmError" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function Hls_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
Hls.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Hls = __decorate([
    ProxyCmp({
        inputs: HlsInputs,
        methods: HlsMethods,
    })
], Hls);

const IconInputs = [
    'name',
    'src',
    'label',
    'library',
    'icons',
];
const IconMethods = [
    'redraw',
];
const IconOutputs = [
    'vmLoad',
    'vmError',
];
let Icon = class Icon {
    constructor(c, r, z) {
        this.z = z;
        define('vm-icon', VmIcon);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmLoad', 'vmError']);
    }
};
Icon.ɵfac = function Icon_Factory(t) { return new (t || Icon)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
Icon.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: Icon, selectors: [["vm-icon"]], inputs: { name: "name", src: "src", label: "label", library: "library", icons: "icons" }, outputs: { vmLoad: "vmLoad", vmError: "vmError" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function Icon_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
Icon.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Icon = __decorate([
    ProxyCmp({
        inputs: IconInputs,
        methods: IconMethods,
    })
], Icon);

const IconLibraryInputs = [
    'name',
    'resolver',
    'icons',
];
const IconLibraryMethods = [];
const IconLibraryOutputs = [];
let IconLibrary = class IconLibrary {
    constructor(c, r, z) {
        this.z = z;
        define('vm-icon-library', VmIconLibrary);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
IconLibrary.ɵfac = function IconLibrary_Factory(t) { return new (t || IconLibrary)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IconLibrary.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: IconLibrary, selectors: [["vm-icon-library"]], inputs: { name: "name", resolver: "resolver", icons: "icons" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function IconLibrary_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
IconLibrary.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
IconLibrary = __decorate([
    ProxyCmp({
        inputs: IconLibraryInputs,
        methods: IconLibraryMethods,
    })
], IconLibrary);

const LiveIndicatorInputs = [
    'isLive',
    'i18n',
];
const LiveIndicatorMethods = [];
const LiveIndicatorOutputs = [];
let LiveIndicator = class LiveIndicator {
    constructor(c, r, z) {
        this.z = z;
        define('vm-live-indicator', VmLiveIndicator);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
LiveIndicator.ɵfac = function LiveIndicator_Factory(t) { return new (t || LiveIndicator)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
LiveIndicator.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: LiveIndicator, selectors: [["vm-live-indicator"]], inputs: { isLive: "isLive", i18n: "i18n" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function LiveIndicator_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
LiveIndicator.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
LiveIndicator = __decorate([
    ProxyCmp({
        inputs: LiveIndicatorInputs,
        methods: LiveIndicatorMethods,
    })
], LiveIndicator);

const LoadingScreenInputs = [
    'playbackReady',
    'hideDots',
];
const LoadingScreenMethods = [];
const LoadingScreenOutputs = [];
let LoadingScreen = class LoadingScreen {
    constructor(c, r, z) {
        this.z = z;
        define('vm-loading-screen', VmLoadingScreen);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
LoadingScreen.ɵfac = function LoadingScreen_Factory(t) { return new (t || LoadingScreen)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
LoadingScreen.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: LoadingScreen, selectors: [["vm-loading-screen"]], inputs: { playbackReady: "playbackReady", hideDots: "hideDots" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function LoadingScreen_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
LoadingScreen.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
LoadingScreen = __decorate([
    ProxyCmp({
        inputs: LoadingScreenInputs,
        methods: LoadingScreenMethods,
    })
], LoadingScreen);

const MenuInputs = [
    'active',
    'identifier',
    'controller',
    'slideInDirection',
];
const MenuMethods = [
    'focusMenu',
    'blurMenu',
    'getActiveMenuItem',
    'setActiveMenuItem',
    'calculateHeight',
];
const MenuOutputs = [
    'vmOpen',
    'vmClose',
    'vmFocus',
    'vmBlur',
    'vmActiveSubmenuChange',
    'vmActiveMenuItemChange',
    'vmMenuHeightChange',
];
let Menu = class Menu {
    constructor(c, r, z) {
        this.z = z;
        define('vm-menu', VmMenu);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmOpen', 'vmClose', 'vmFocus', 'vmBlur', 'vmActiveSubmenuChange', 'vmActiveMenuItemChange', 'vmMenuHeightChange']);
    }
};
Menu.ɵfac = function Menu_Factory(t) { return new (t || Menu)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
Menu.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: Menu, selectors: [["vm-menu"]], inputs: { active: "active", identifier: "identifier", controller: "controller", slideInDirection: "slideInDirection" }, outputs: { vmOpen: "vmOpen", vmClose: "vmClose", vmFocus: "vmFocus", vmBlur: "vmBlur", vmActiveSubmenuChange: "vmActiveSubmenuChange", vmActiveMenuItemChange: "vmActiveMenuItemChange", vmMenuHeightChange: "vmMenuHeightChange" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function Menu_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
Menu.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Menu = __decorate([
    ProxyCmp({
        inputs: MenuInputs,
        methods: MenuMethods,
    })
], Menu);

const MenuItemInputs = [
    'identifier',
    'hidden',
    'label',
    'menu',
    'expanded',
    'checked',
    'hint',
    'badge',
    'checkIcon',
    'icons',
    'isTouch',
];
const MenuItemMethods = [
    'focusItem',
    'blurItem',
    'getHeight',
];
const MenuItemOutputs = [
    'vmFocus',
    'vmBlur',
];
let MenuItem = class MenuItem {
    constructor(c, r, z) {
        this.z = z;
        define('vm-menu-item', VmMenuItem);
        define('vm-icon', VmIcon);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmFocus', 'vmBlur']);
    }
};
MenuItem.ɵfac = function MenuItem_Factory(t) { return new (t || MenuItem)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
MenuItem.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: MenuItem, selectors: [["vm-menu-item"]], inputs: { identifier: "identifier", hidden: "hidden", label: "label", menu: "menu", expanded: "expanded", checked: "checked", hint: "hint", badge: "badge", checkIcon: "checkIcon", icons: "icons", isTouch: "isTouch" }, outputs: { vmFocus: "vmFocus", vmBlur: "vmBlur" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function MenuItem_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
MenuItem.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
MenuItem = __decorate([
    ProxyCmp({
        inputs: MenuItemInputs,
        methods: MenuItemMethods,
    })
], MenuItem);

const MenuRadioInputs = [
    'label',
    'value',
    'checked',
    'badge',
    'checkIcon',
    'icons',
];
const MenuRadioMethods = [];
const MenuRadioOutputs = [
    'vmCheck',
];
let MenuRadio = class MenuRadio {
    constructor(c, r, z) {
        this.z = z;
        define('vm-menu-radio', VmMenuRadio);
        define('vm-icon', VmIcon);
        define('vm-menu-item', VmMenuItem);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmCheck']);
    }
};
MenuRadio.ɵfac = function MenuRadio_Factory(t) { return new (t || MenuRadio)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
MenuRadio.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: MenuRadio, selectors: [["vm-menu-radio"]], inputs: { label: "label", value: "value", checked: "checked", badge: "badge", checkIcon: "checkIcon", icons: "icons" }, outputs: { vmCheck: "vmCheck" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function MenuRadio_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
MenuRadio.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
MenuRadio = __decorate([
    ProxyCmp({
        inputs: MenuRadioInputs,
        methods: MenuRadioMethods,
    })
], MenuRadio);

const MenuRadioGroupInputs = [
    'value',
];
const MenuRadioGroupMethods = [];
const MenuRadioGroupOutputs = [
    'vmCheck',
];
let MenuRadioGroup = class MenuRadioGroup {
    constructor(c, r, z) {
        this.z = z;
        define('vm-menu-radio-group', VmMenuRadioGroup);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmCheck']);
    }
};
MenuRadioGroup.ɵfac = function MenuRadioGroup_Factory(t) { return new (t || MenuRadioGroup)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
MenuRadioGroup.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: MenuRadioGroup, selectors: [["vm-menu-radio-group"]], inputs: { value: "value" }, outputs: { vmCheck: "vmCheck" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function MenuRadioGroup_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
MenuRadioGroup.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
MenuRadioGroup = __decorate([
    ProxyCmp({
        inputs: MenuRadioGroupInputs,
        methods: MenuRadioGroupMethods,
    })
], MenuRadioGroup);

const MuteControlInputs = [
    'lowVolumeIcon',
    'highVolumeIcon',
    'mutedIcon',
    'icons',
    'tooltipPosition',
    'tooltipDirection',
    'hideTooltip',
    'keys',
    'volume',
    'muted',
    'i18n',
];
const MuteControlMethods = [];
const MuteControlOutputs = [
    'vmFocus',
    'vmBlur',
];
let MuteControl = class MuteControl {
    constructor(c, r, z) {
        this.z = z;
        define('vm-mute-control', VmMuteControl);
        define('vm-control', VmControl);
        define('vm-icon', VmIcon);
        define('vm-tooltip', VmTooltip);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmFocus', 'vmBlur']);
    }
};
MuteControl.ɵfac = function MuteControl_Factory(t) { return new (t || MuteControl)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
MuteControl.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: MuteControl, selectors: [["vm-mute-control"]], inputs: { lowVolumeIcon: "lowVolumeIcon", highVolumeIcon: "highVolumeIcon", mutedIcon: "mutedIcon", icons: "icons", tooltipPosition: "tooltipPosition", tooltipDirection: "tooltipDirection", hideTooltip: "hideTooltip", keys: "keys", volume: "volume", muted: "muted", i18n: "i18n" }, outputs: { vmFocus: "vmFocus", vmBlur: "vmBlur" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function MuteControl_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
MuteControl.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
MuteControl = __decorate([
    ProxyCmp({
        inputs: MuteControlInputs,
        methods: MuteControlMethods,
    })
], MuteControl);

const PipControlInputs = [
    'enterIcon',
    'exitIcon',
    'icons',
    'tooltipPosition',
    'tooltipDirection',
    'hideTooltip',
    'keys',
    'isPiPActive',
    'i18n',
    'playbackReady',
];
const PipControlMethods = [];
const PipControlOutputs = [];
let PipControl = class PipControl {
    constructor(c, r, z) {
        this.z = z;
        define('vm-pip-control', VmPipControl);
        define('vm-control', VmControl);
        define('vm-icon', VmIcon);
        define('vm-tooltip', VmTooltip);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
PipControl.ɵfac = function PipControl_Factory(t) { return new (t || PipControl)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
PipControl.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: PipControl, selectors: [["vm-pip-control"]], inputs: { enterIcon: "enterIcon", exitIcon: "exitIcon", icons: "icons", tooltipPosition: "tooltipPosition", tooltipDirection: "tooltipDirection", hideTooltip: "hideTooltip", keys: "keys", isPiPActive: "isPiPActive", i18n: "i18n", playbackReady: "playbackReady" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function PipControl_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
PipControl.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
PipControl = __decorate([
    ProxyCmp({
        inputs: PipControlInputs,
        methods: PipControlMethods,
    })
], PipControl);

const PlaybackControlInputs = [
    'playIcon',
    'pauseIcon',
    'icons',
    'tooltipPosition',
    'tooltipDirection',
    'hideTooltip',
    'keys',
    'paused',
    'i18n',
];
const PlaybackControlMethods = [];
const PlaybackControlOutputs = [];
let PlaybackControl = class PlaybackControl {
    constructor(c, r, z) {
        this.z = z;
        define('vm-playback-control', VmPlaybackControl);
        define('vm-control', VmControl);
        define('vm-icon', VmIcon);
        define('vm-tooltip', VmTooltip);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
PlaybackControl.ɵfac = function PlaybackControl_Factory(t) { return new (t || PlaybackControl)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
PlaybackControl.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: PlaybackControl, selectors: [["vm-playback-control"]], inputs: { playIcon: "playIcon", pauseIcon: "pauseIcon", icons: "icons", tooltipPosition: "tooltipPosition", tooltipDirection: "tooltipDirection", hideTooltip: "hideTooltip", keys: "keys", paused: "paused", i18n: "i18n" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function PlaybackControl_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
PlaybackControl.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
PlaybackControl = __decorate([
    ProxyCmp({
        inputs: PlaybackControlInputs,
        methods: PlaybackControlMethods,
    })
], PlaybackControl);

const PlayerInputs = [
    'logger',
    'theme',
    'icons',
    'paused',
    'playing',
    'duration',
    'mediaTitle',
    'currentProvider',
    'currentSrc',
    'currentPoster',
    'currentTime',
    'autoplay',
    'ready',
    'playbackReady',
    'loop',
    'muted',
    'buffered',
    'playbackRate',
    'playbackRates',
    'playbackQuality',
    'playbackQualities',
    'seeking',
    'debug',
    'playbackStarted',
    'playbackEnded',
    'buffering',
    'controls',
    'isControlsActive',
    'isSettingsActive',
    'volume',
    'isFullscreenActive',
    'aspectRatio',
    'viewType',
    'isAudioView',
    'isVideoView',
    'mediaType',
    'isAudio',
    'isVideo',
    'isLive',
    'isMobile',
    'isTouch',
    'isPiPActive',
    'textTracks',
    'currentTextTrack',
    'isTextTrackVisible',
    'shouldRenderNativeTextTracks',
    'audioTracks',
    'currentAudioTrack',
    'autopause',
    'playsinline',
    'language',
    'translations',
    'languages',
    'i18n',
];
const PlayerMethods = [
    'getProvider',
    'getAdapter',
    'play',
    'pause',
    'canPlay',
    'canAutoplay',
    'canMutedAutoplay',
    'canSetPlaybackRate',
    'canSetPlaybackQuality',
    'canSetFullscreen',
    'enterFullscreen',
    'exitFullscreen',
    'canSetPiP',
    'enterPiP',
    'exitPiP',
    'canSetAudioTrack',
    'setCurrentAudioTrack',
    'canSetTextTrack',
    'setCurrentTextTrack',
    'canSetTextTrackVisibility',
    'setTextTrackVisibility',
    'extendLanguage',
    'getContainer',
    'callAdapter',
];
const PlayerOutputs = [
    'vmThemeChange',
    'vmPausedChange',
    'vmPlay',
    'vmPlayingChange',
    'vmSeekingChange',
    'vmSeeked',
    'vmBufferingChange',
    'vmDurationChange',
    'vmCurrentTimeChange',
    'vmReady',
    'vmPlaybackReady',
    'vmPlaybackStarted',
    'vmPlaybackEnded',
    'vmBufferedChange',
    'vmError',
    'vmLoadStart',
    'vmCurrentProviderChange',
    'vmCurrentSrcChange',
    'vmCurrentPosterChange',
    'vmMediaTitleChange',
    'vmControlsChange',
    'vmPlaybackRateChange',
    'vmPlaybackRatesChange',
    'vmPlaybackQualityChange',
    'vmPlaybackQualitiesChange',
    'vmMutedChange',
    'vmVolumeChange',
    'vmViewTypeChange',
    'vmMediaTypeChange',
    'vmLiveChange',
    'vmTouchChange',
    'vmLanguageChange',
    'vmI18nChange',
    'vmTranslationsChange',
    'vmLanguagesChange',
    'vmFullscreenChange',
    'vmPiPChange',
    'vmTextTracksChange',
    'vmCurrentTextTrackChange',
    'vmTextTrackVisibleChange',
    'vmAudioTracksChange',
    'vmCurrentAudioTrackChange',
];
let Player = class Player {
    constructor(c, r, z) {
        this.z = z;
        define('vm-player', VmPlayer);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmThemeChange', 'vmPausedChange', 'vmPlay', 'vmPlayingChange', 'vmSeekingChange', 'vmSeeked', 'vmBufferingChange', 'vmDurationChange', 'vmCurrentTimeChange', 'vmReady', 'vmPlaybackReady', 'vmPlaybackStarted', 'vmPlaybackEnded', 'vmBufferedChange', 'vmError', 'vmLoadStart', 'vmCurrentProviderChange', 'vmCurrentSrcChange', 'vmCurrentPosterChange', 'vmMediaTitleChange', 'vmControlsChange', 'vmPlaybackRateChange', 'vmPlaybackRatesChange', 'vmPlaybackQualityChange', 'vmPlaybackQualitiesChange', 'vmMutedChange', 'vmVolumeChange', 'vmViewTypeChange', 'vmMediaTypeChange', 'vmLiveChange', 'vmTouchChange', 'vmLanguageChange', 'vmI18nChange', 'vmTranslationsChange', 'vmLanguagesChange', 'vmFullscreenChange', 'vmPiPChange', 'vmTextTracksChange', 'vmCurrentTextTrackChange', 'vmTextTrackVisibleChange', 'vmAudioTracksChange', 'vmCurrentAudioTrackChange']);
    }
};
Player.ɵfac = function Player_Factory(t) { return new (t || Player)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
Player.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: Player, selectors: [["vm-player"]], inputs: { logger: "logger", theme: "theme", icons: "icons", paused: "paused", playing: "playing", duration: "duration", mediaTitle: "mediaTitle", currentProvider: "currentProvider", currentSrc: "currentSrc", currentPoster: "currentPoster", currentTime: "currentTime", autoplay: "autoplay", ready: "ready", playbackReady: "playbackReady", loop: "loop", muted: "muted", buffered: "buffered", playbackRate: "playbackRate", playbackRates: "playbackRates", playbackQuality: "playbackQuality", playbackQualities: "playbackQualities", seeking: "seeking", debug: "debug", playbackStarted: "playbackStarted", playbackEnded: "playbackEnded", buffering: "buffering", controls: "controls", isControlsActive: "isControlsActive", isSettingsActive: "isSettingsActive", volume: "volume", isFullscreenActive: "isFullscreenActive", aspectRatio: "aspectRatio", viewType: "viewType", isAudioView: "isAudioView", isVideoView: "isVideoView", mediaType: "mediaType", isAudio: "isAudio", isVideo: "isVideo", isLive: "isLive", isMobile: "isMobile", isTouch: "isTouch", isPiPActive: "isPiPActive", textTracks: "textTracks", currentTextTrack: "currentTextTrack", isTextTrackVisible: "isTextTrackVisible", shouldRenderNativeTextTracks: "shouldRenderNativeTextTracks", audioTracks: "audioTracks", currentAudioTrack: "currentAudioTrack", autopause: "autopause", playsinline: "playsinline", language: "language", translations: "translations", languages: "languages", i18n: "i18n" }, outputs: { vmThemeChange: "vmThemeChange", vmPausedChange: "vmPausedChange", vmPlay: "vmPlay", vmPlayingChange: "vmPlayingChange", vmSeekingChange: "vmSeekingChange", vmSeeked: "vmSeeked", vmBufferingChange: "vmBufferingChange", vmDurationChange: "vmDurationChange", vmCurrentTimeChange: "vmCurrentTimeChange", vmReady: "vmReady", vmPlaybackReady: "vmPlaybackReady", vmPlaybackStarted: "vmPlaybackStarted", vmPlaybackEnded: "vmPlaybackEnded", vmBufferedChange: "vmBufferedChange", vmError: "vmError", vmLoadStart: "vmLoadStart", vmCurrentProviderChange: "vmCurrentProviderChange", vmCurrentSrcChange: "vmCurrentSrcChange", vmCurrentPosterChange: "vmCurrentPosterChange", vmMediaTitleChange: "vmMediaTitleChange", vmControlsChange: "vmControlsChange", vmPlaybackRateChange: "vmPlaybackRateChange", vmPlaybackRatesChange: "vmPlaybackRatesChange", vmPlaybackQualityChange: "vmPlaybackQualityChange", vmPlaybackQualitiesChange: "vmPlaybackQualitiesChange", vmMutedChange: "vmMutedChange", vmVolumeChange: "vmVolumeChange", vmViewTypeChange: "vmViewTypeChange", vmMediaTypeChange: "vmMediaTypeChange", vmLiveChange: "vmLiveChange", vmTouchChange: "vmTouchChange", vmLanguageChange: "vmLanguageChange", vmI18nChange: "vmI18nChange", vmTranslationsChange: "vmTranslationsChange", vmLanguagesChange: "vmLanguagesChange", vmFullscreenChange: "vmFullscreenChange", vmPiPChange: "vmPiPChange", vmTextTracksChange: "vmTextTracksChange", vmCurrentTextTrackChange: "vmCurrentTextTrackChange", vmTextTrackVisibleChange: "vmTextTrackVisibleChange", vmAudioTracksChange: "vmAudioTracksChange", vmCurrentAudioTrackChange: "vmCurrentAudioTrackChange" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function Player_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
Player.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Player = __decorate([
    ProxyCmp({
        inputs: PlayerInputs,
        methods: PlayerMethods,
    })
], Player);

const PosterInputs = [
    'fit',
    'isVideoView',
    'currentPoster',
    'mediaTitle',
    'playbackStarted',
    'currentTime',
];
const PosterMethods = [];
const PosterOutputs = [
    'vmLoaded',
    'vmWillShow',
    'vmWillHide',
];
let Poster = class Poster {
    constructor(c, r, z) {
        this.z = z;
        define('vm-poster', VmPoster);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmLoaded', 'vmWillShow', 'vmWillHide']);
    }
};
Poster.ɵfac = function Poster_Factory(t) { return new (t || Poster)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
Poster.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: Poster, selectors: [["vm-poster"]], inputs: { fit: "fit", isVideoView: "isVideoView", currentPoster: "currentPoster", mediaTitle: "mediaTitle", playbackStarted: "playbackStarted", currentTime: "currentTime" }, outputs: { vmLoaded: "vmLoaded", vmWillShow: "vmWillShow", vmWillHide: "vmWillHide" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function Poster_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
Poster.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Poster = __decorate([
    ProxyCmp({
        inputs: PosterInputs,
        methods: PosterMethods,
    })
], Poster);

const ScrimInputs = [
    'gradient',
    'isVideoView',
    'isControlsActive',
];
const ScrimMethods = [];
const ScrimOutputs = [];
let Scrim = class Scrim {
    constructor(c, r, z) {
        this.z = z;
        define('vm-scrim', VmScrim);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
Scrim.ɵfac = function Scrim_Factory(t) { return new (t || Scrim)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
Scrim.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: Scrim, selectors: [["vm-scrim"]], inputs: { gradient: "gradient", isVideoView: "isVideoView", isControlsActive: "isControlsActive" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function Scrim_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
Scrim.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Scrim = __decorate([
    ProxyCmp({
        inputs: ScrimInputs,
        methods: ScrimMethods,
    })
], Scrim);

const ScrubberControlInputs = [
    'alwaysShowHours',
    'hideTooltip',
    'currentTime',
    'duration',
    'noKeyboard',
    'buffering',
    'buffered',
    'i18n',
];
const ScrubberControlMethods = [];
const ScrubberControlOutputs = [];
let ScrubberControl = class ScrubberControl {
    constructor(c, r, z) {
        this.z = z;
        define('vm-scrubber-control', VmScrubberControl);
        define('vm-slider', VmSlider);
        define('vm-tooltip', VmTooltip);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
ScrubberControl.ɵfac = function ScrubberControl_Factory(t) { return new (t || ScrubberControl)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
ScrubberControl.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ScrubberControl, selectors: [["vm-scrubber-control"]], inputs: { alwaysShowHours: "alwaysShowHours", hideTooltip: "hideTooltip", currentTime: "currentTime", duration: "duration", noKeyboard: "noKeyboard", buffering: "buffering", buffered: "buffered", i18n: "i18n" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function ScrubberControl_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
ScrubberControl.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
ScrubberControl = __decorate([
    ProxyCmp({
        inputs: ScrubberControlInputs,
        methods: ScrubberControlMethods,
    })
], ScrubberControl);

const SettingsInputs = [
    'pin',
    'active',
    'isMobile',
    'isAudioView',
];
const SettingsMethods = [
    'setController',
];
const SettingsOutputs = [];
let Settings = class Settings {
    constructor(c, r, z) {
        this.z = z;
        define('vm-settings', VmSettings);
        define('vm-menu', VmMenu);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
Settings.ɵfac = function Settings_Factory(t) { return new (t || Settings)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
Settings.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: Settings, selectors: [["vm-settings"]], inputs: { pin: "pin", active: "active", isMobile: "isMobile", isAudioView: "isAudioView" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function Settings_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
Settings.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Settings = __decorate([
    ProxyCmp({
        inputs: SettingsInputs,
        methods: SettingsMethods,
    })
], Settings);

const SettingsControlInputs = [
    'icon',
    'icons',
    'tooltipPosition',
    'tooltipDirection',
    'menu',
    'expanded',
    'i18n',
    'hideTooltip',
];
const SettingsControlMethods = [
    'focusControl',
    'blurControl',
];
const SettingsControlOutputs = [];
let SettingsControl = class SettingsControl {
    constructor(c, r, z) {
        this.z = z;
        define('vm-settings-control', VmSettingsControl);
        define('vm-control', VmControl);
        define('vm-icon', VmIcon);
        define('vm-tooltip', VmTooltip);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
SettingsControl.ɵfac = function SettingsControl_Factory(t) { return new (t || SettingsControl)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
SettingsControl.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: SettingsControl, selectors: [["vm-settings-control"]], inputs: { icon: "icon", icons: "icons", tooltipPosition: "tooltipPosition", tooltipDirection: "tooltipDirection", menu: "menu", expanded: "expanded", i18n: "i18n", hideTooltip: "hideTooltip" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function SettingsControl_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
SettingsControl.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
SettingsControl = __decorate([
    ProxyCmp({
        inputs: SettingsControlInputs,
        methods: SettingsControlMethods,
    })
], SettingsControl);

const SkeletonInputs = [
    'effect',
    'ready',
];
const SkeletonMethods = [];
const SkeletonOutputs = [];
let Skeleton = class Skeleton {
    constructor(c, r, z) {
        this.z = z;
        define('vm-skeleton', VmSkeleton);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
Skeleton.ɵfac = function Skeleton_Factory(t) { return new (t || Skeleton)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
Skeleton.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: Skeleton, selectors: [["vm-skeleton"]], inputs: { effect: "effect", ready: "ready" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function Skeleton_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
Skeleton.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Skeleton = __decorate([
    ProxyCmp({
        inputs: SkeletonInputs,
        methods: SkeletonMethods,
    })
], Skeleton);

const SliderInputs = [
    'step',
    'min',
    'max',
    'value',
    'valueText',
    'label',
];
const SliderMethods = [];
const SliderOutputs = [
    'vmValueChange',
    'vmFocus',
    'vmBlur',
];
let Slider = class Slider {
    constructor(c, r, z) {
        this.z = z;
        define('vm-slider', VmSlider);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmValueChange', 'vmFocus', 'vmBlur']);
    }
};
Slider.ɵfac = function Slider_Factory(t) { return new (t || Slider)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
Slider.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: Slider, selectors: [["vm-slider"]], inputs: { step: "step", min: "min", max: "max", value: "value", valueText: "valueText", label: "label" }, outputs: { vmValueChange: "vmValueChange", vmFocus: "vmFocus", vmBlur: "vmBlur" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function Slider_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
Slider.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Slider = __decorate([
    ProxyCmp({
        inputs: SliderInputs,
        methods: SliderMethods,
    })
], Slider);

const SpinnerInputs = [
    'isVideoView',
    'currentProvider',
    'showWhenMediaLoading',
    'playbackReady',
    'buffering',
];
const SpinnerMethods = [];
const SpinnerOutputs = [
    'vmWillShow',
    'vmWillHide',
];
let Spinner = class Spinner {
    constructor(c, r, z) {
        this.z = z;
        define('vm-spinner', VmSpinner);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmWillShow', 'vmWillHide']);
    }
};
Spinner.ɵfac = function Spinner_Factory(t) { return new (t || Spinner)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
Spinner.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: Spinner, selectors: [["vm-spinner"]], inputs: { isVideoView: "isVideoView", currentProvider: "currentProvider", showWhenMediaLoading: "showWhenMediaLoading", playbackReady: "playbackReady", buffering: "buffering" }, outputs: { vmWillShow: "vmWillShow", vmWillHide: "vmWillHide" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function Spinner_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
Spinner.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Spinner = __decorate([
    ProxyCmp({
        inputs: SpinnerInputs,
        methods: SpinnerMethods,
    })
], Spinner);

const SubmenuInputs = [
    'label',
    'hint',
    'slideInDirection',
    'active',
];
const SubmenuMethods = [
    'getController',
    'getMenu',
    'getControllerHeight',
];
const SubmenuOutputs = [
    'vmOpenSubmenu',
    'vmCloseSubmenu',
];
let Submenu = class Submenu {
    constructor(c, r, z) {
        this.z = z;
        define('vm-submenu', VmSubmenu);
        define('vm-icon', VmIcon);
        define('vm-menu', VmMenu);
        define('vm-menu-item', VmMenuItem);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmOpenSubmenu', 'vmCloseSubmenu']);
    }
};
Submenu.ɵfac = function Submenu_Factory(t) { return new (t || Submenu)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
Submenu.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: Submenu, selectors: [["vm-submenu"]], inputs: { label: "label", hint: "hint", slideInDirection: "slideInDirection", active: "active" }, outputs: { vmOpenSubmenu: "vmOpenSubmenu", vmCloseSubmenu: "vmCloseSubmenu" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function Submenu_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
Submenu.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Submenu = __decorate([
    ProxyCmp({
        inputs: SubmenuInputs,
        methods: SubmenuMethods,
    })
], Submenu);

const TimeInputs = [
    'label',
    'seconds',
    'alwaysShowHours',
];
const TimeMethods = [];
const TimeOutputs = [];
let Time = class Time {
    constructor(c, r, z) {
        this.z = z;
        define('vm-time', VmTime);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
Time.ɵfac = function Time_Factory(t) { return new (t || Time)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
Time.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: Time, selectors: [["vm-time"]], inputs: { label: "label", seconds: "seconds", alwaysShowHours: "alwaysShowHours" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function Time_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
Time.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Time = __decorate([
    ProxyCmp({
        inputs: TimeInputs,
        methods: TimeMethods,
    })
], Time);

const TimeProgressInputs = [
    'separator',
    'alwaysShowHours',
];
const TimeProgressMethods = [];
const TimeProgressOutputs = [];
let TimeProgress = class TimeProgress {
    constructor(c, r, z) {
        this.z = z;
        define('vm-time-progress', VmTimeProgress);
        define('vm-current-time', VmCurrentTime);
        define('vm-time', VmTime);
        define('vm-end-time', VmEndTime);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
TimeProgress.ɵfac = function TimeProgress_Factory(t) { return new (t || TimeProgress)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
TimeProgress.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: TimeProgress, selectors: [["vm-time-progress"]], inputs: { separator: "separator", alwaysShowHours: "alwaysShowHours" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function TimeProgress_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
TimeProgress.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
TimeProgress = __decorate([
    ProxyCmp({
        inputs: TimeProgressInputs,
        methods: TimeProgressMethods,
    })
], TimeProgress);

const TooltipInputs = [
    'hidden',
    'active',
    'position',
    'direction',
    'isTouch',
    'isMobile',
];
const TooltipMethods = [];
const TooltipOutputs = [];
let Tooltip = class Tooltip {
    constructor(c, r, z) {
        this.z = z;
        define('vm-tooltip', VmTooltip);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
Tooltip.ɵfac = function Tooltip_Factory(t) { return new (t || Tooltip)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
Tooltip.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: Tooltip, selectors: [["vm-tooltip"]], inputs: { hidden: "hidden", active: "active", position: "position", direction: "direction", isTouch: "isTouch", isMobile: "isMobile" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function Tooltip_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
Tooltip.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Tooltip = __decorate([
    ProxyCmp({
        inputs: TooltipInputs,
        methods: TooltipMethods,
    })
], Tooltip);

const UiInputs = [
    'isVideoView',
    'playsinline',
    'isFullscreenActive',
];
const UiMethods = [];
const UiOutputs = [];
let Ui = class Ui {
    constructor(c, r, z) {
        this.z = z;
        define('vm-ui', VmUi);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
Ui.ɵfac = function Ui_Factory(t) { return new (t || Ui)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
Ui.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: Ui, selectors: [["vm-ui"]], inputs: { isVideoView: "isVideoView", playsinline: "playsinline", isFullscreenActive: "isFullscreenActive" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function Ui_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
Ui.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Ui = __decorate([
    ProxyCmp({
        inputs: UiInputs,
        methods: UiMethods,
    })
], Ui);

const VideoInputs = [
    'willAttach',
    'hasCustomTextManager',
    'crossOrigin',
    'preload',
    'poster',
    'controlsList',
    'autoPiP',
    'disablePiP',
    'disableRemotePlayback',
    'mediaTitle',
];
const VideoMethods = [
    'getAdapter',
];
const VideoOutputs = [];
let Video = class Video {
    constructor(c, r, z) {
        this.z = z;
        define('vm-video', VmVideo);
        define('vm-file', VmFile);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
Video.ɵfac = function Video_Factory(t) { return new (t || Video)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
Video.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: Video, selectors: [["vm-video"]], inputs: { willAttach: "willAttach", hasCustomTextManager: "hasCustomTextManager", crossOrigin: "crossOrigin", preload: "preload", poster: "poster", controlsList: "controlsList", autoPiP: "autoPiP", disablePiP: "disablePiP", disableRemotePlayback: "disableRemotePlayback", mediaTitle: "mediaTitle" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function Video_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
Video.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Video = __decorate([
    ProxyCmp({
        inputs: VideoInputs,
        methods: VideoMethods,
    })
], Video);

const VimeoInputs = [
    'videoId',
    'byline',
    'color',
    'portrait',
    'noAutoAspectRatio',
    'poster',
    'cookies',
    'language',
    'aspectRatio',
    'autoplay',
    'controls',
    'logger',
    'loop',
    'muted',
    'playsinline',
];
const VimeoMethods = [
    'getAdapter',
];
const VimeoOutputs = [
    'vmError',
];
let Vimeo = class Vimeo {
    constructor(c, r, z) {
        this.z = z;
        define('vm-vimeo', VmVimeo);
        define('vm-embed', VmEmbed);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmError']);
    }
};
Vimeo.ɵfac = function Vimeo_Factory(t) { return new (t || Vimeo)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
Vimeo.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: Vimeo, selectors: [["vm-vimeo"]], inputs: { videoId: "videoId", byline: "byline", color: "color", portrait: "portrait", noAutoAspectRatio: "noAutoAspectRatio", poster: "poster", cookies: "cookies", language: "language", aspectRatio: "aspectRatio", autoplay: "autoplay", controls: "controls", logger: "logger", loop: "loop", muted: "muted", playsinline: "playsinline" }, outputs: { vmError: "vmError" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function Vimeo_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
Vimeo.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Vimeo = __decorate([
    ProxyCmp({
        inputs: VimeoInputs,
        methods: VimeoMethods,
    })
], Vimeo);

const VolumeControlInputs = [
    'lowVolumeIcon',
    'highVolumeIcon',
    'mutedIcon',
    'icons',
    'tooltipPosition',
    'tooltipDirection',
    'hideTooltip',
    'muteKeys',
    'noKeyboard',
    'muted',
    'volume',
    'isMobile',
    'i18n',
];
const VolumeControlMethods = [];
const VolumeControlOutputs = [];
let VolumeControl = class VolumeControl {
    constructor(c, r, z) {
        this.z = z;
        define('vm-volume-control', VmVolumeControl);
        define('vm-control', VmControl);
        define('vm-icon', VmIcon);
        define('vm-mute-control', VmMuteControl);
        define('vm-tooltip', VmTooltip);
        define('vm-slider', VmSlider);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
VolumeControl.ɵfac = function VolumeControl_Factory(t) { return new (t || VolumeControl)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
VolumeControl.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: VolumeControl, selectors: [["vm-volume-control"]], inputs: { lowVolumeIcon: "lowVolumeIcon", highVolumeIcon: "highVolumeIcon", mutedIcon: "mutedIcon", icons: "icons", tooltipPosition: "tooltipPosition", tooltipDirection: "tooltipDirection", hideTooltip: "hideTooltip", muteKeys: "muteKeys", noKeyboard: "noKeyboard", muted: "muted", volume: "volume", isMobile: "isMobile", i18n: "i18n" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function VolumeControl_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
VolumeControl.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
VolumeControl = __decorate([
    ProxyCmp({
        inputs: VolumeControlInputs,
        methods: VolumeControlMethods,
    })
], VolumeControl);

const YoutubeInputs = [
    'cookies',
    'videoId',
    'showFullscreenControl',
    'poster',
    'language',
    'autoplay',
    'controls',
    'logger',
    'loop',
    'muted',
    'playsinline',
];
const YoutubeMethods = [
    'getAdapter',
];
const YoutubeOutputs = [];
let Youtube = class Youtube {
    constructor(c, r, z) {
        this.z = z;
        define('vm-youtube', VmYoutube);
        define('vm-embed', VmEmbed);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
Youtube.ɵfac = function Youtube_Factory(t) { return new (t || Youtube)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
Youtube.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: Youtube, selectors: [["vm-youtube"]], inputs: { cookies: "cookies", videoId: "videoId", showFullscreenControl: "showFullscreenControl", poster: "poster", language: "language", autoplay: "autoplay", controls: "controls", logger: "logger", loop: "loop", muted: "muted", playsinline: "playsinline" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function Youtube_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
Youtube.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Youtube = __decorate([
    ProxyCmp({
        inputs: YoutubeInputs,
        methods: YoutubeMethods,
    })
], Youtube);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Audio, [{
        type: Component,
        args: [{
                selector: 'vm-audio',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: AudioInputs,
                outputs: AudioOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CaptionControl, [{
        type: Component,
        args: [{
                selector: 'vm-caption-control',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: CaptionControlInputs,
                outputs: CaptionControlOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Captions, [{
        type: Component,
        args: [{
                selector: 'vm-captions',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: CaptionsInputs,
                outputs: CaptionsOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ClickToPlay, [{
        type: Component,
        args: [{
                selector: 'vm-click-to-play',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: ClickToPlayInputs,
                outputs: ClickToPlayOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Control, [{
        type: Component,
        args: [{
                selector: 'vm-control',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: ControlInputs,
                outputs: ControlOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ControlGroup, [{
        type: Component,
        args: [{
                selector: 'vm-control-group',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: ControlGroupInputs,
                outputs: ControlGroupOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ControlSpacer, [{
        type: Component,
        args: [{
                selector: 'vm-control-spacer',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: ControlSpacerInputs,
                outputs: ControlSpacerOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Controls, [{
        type: Component,
        args: [{
                selector: 'vm-controls',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: ControlsInputs,
                outputs: ControlsOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CurrentTime, [{
        type: Component,
        args: [{
                selector: 'vm-current-time',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: CurrentTimeInputs,
                outputs: CurrentTimeOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Dailymotion, [{
        type: Component,
        args: [{
                selector: 'vm-dailymotion',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: DailymotionInputs,
                outputs: DailymotionOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Dash, [{
        type: Component,
        args: [{
                selector: 'vm-dash',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: DashInputs,
                outputs: DashOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DblClickFullscreen, [{
        type: Component,
        args: [{
                selector: 'vm-dbl-click-fullscreen',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: DblClickFullscreenInputs,
                outputs: DblClickFullscreenOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DefaultControls, [{
        type: Component,
        args: [{
                selector: 'vm-default-controls',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: DefaultControlsInputs,
                outputs: DefaultControlsOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DefaultSettings, [{
        type: Component,
        args: [{
                selector: 'vm-default-settings',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: DefaultSettingsInputs,
                outputs: DefaultSettingsOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DefaultUi, [{
        type: Component,
        args: [{
                selector: 'vm-default-ui',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: DefaultUiInputs,
                outputs: DefaultUiOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Embed, [{
        type: Component,
        args: [{
                selector: 'vm-embed',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: EmbedInputs,
                outputs: EmbedOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(EndTime, [{
        type: Component,
        args: [{
                selector: 'vm-end-time',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: EndTimeInputs,
                outputs: EndTimeOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(File, [{
        type: Component,
        args: [{
                selector: 'vm-file',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: FileInputs,
                outputs: FileOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FullscreenControl, [{
        type: Component,
        args: [{
                selector: 'vm-fullscreen-control',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: FullscreenControlInputs,
                outputs: FullscreenControlOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Hls, [{
        type: Component,
        args: [{
                selector: 'vm-hls',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: HlsInputs,
                outputs: HlsOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Icon, [{
        type: Component,
        args: [{
                selector: 'vm-icon',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: IconInputs,
                outputs: IconOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(IconLibrary, [{
        type: Component,
        args: [{
                selector: 'vm-icon-library',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: IconLibraryInputs,
                outputs: IconLibraryOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LiveIndicator, [{
        type: Component,
        args: [{
                selector: 'vm-live-indicator',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: LiveIndicatorInputs,
                outputs: LiveIndicatorOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LoadingScreen, [{
        type: Component,
        args: [{
                selector: 'vm-loading-screen',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: LoadingScreenInputs,
                outputs: LoadingScreenOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Menu, [{
        type: Component,
        args: [{
                selector: 'vm-menu',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: MenuInputs,
                outputs: MenuOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MenuItem, [{
        type: Component,
        args: [{
                selector: 'vm-menu-item',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: MenuItemInputs,
                outputs: MenuItemOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MenuRadio, [{
        type: Component,
        args: [{
                selector: 'vm-menu-radio',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: MenuRadioInputs,
                outputs: MenuRadioOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MenuRadioGroup, [{
        type: Component,
        args: [{
                selector: 'vm-menu-radio-group',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: MenuRadioGroupInputs,
                outputs: MenuRadioGroupOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MuteControl, [{
        type: Component,
        args: [{
                selector: 'vm-mute-control',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: MuteControlInputs,
                outputs: MuteControlOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PipControl, [{
        type: Component,
        args: [{
                selector: 'vm-pip-control',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: PipControlInputs,
                outputs: PipControlOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PlaybackControl, [{
        type: Component,
        args: [{
                selector: 'vm-playback-control',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: PlaybackControlInputs,
                outputs: PlaybackControlOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Player, [{
        type: Component,
        args: [{
                selector: 'vm-player',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: PlayerInputs,
                outputs: PlayerOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Poster, [{
        type: Component,
        args: [{
                selector: 'vm-poster',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: PosterInputs,
                outputs: PosterOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Scrim, [{
        type: Component,
        args: [{
                selector: 'vm-scrim',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: ScrimInputs,
                outputs: ScrimOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ScrubberControl, [{
        type: Component,
        args: [{
                selector: 'vm-scrubber-control',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: ScrubberControlInputs,
                outputs: ScrubberControlOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Settings, [{
        type: Component,
        args: [{
                selector: 'vm-settings',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: SettingsInputs,
                outputs: SettingsOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SettingsControl, [{
        type: Component,
        args: [{
                selector: 'vm-settings-control',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: SettingsControlInputs,
                outputs: SettingsControlOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Skeleton, [{
        type: Component,
        args: [{
                selector: 'vm-skeleton',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: SkeletonInputs,
                outputs: SkeletonOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Slider, [{
        type: Component,
        args: [{
                selector: 'vm-slider',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: SliderInputs,
                outputs: SliderOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Spinner, [{
        type: Component,
        args: [{
                selector: 'vm-spinner',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: SpinnerInputs,
                outputs: SpinnerOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Submenu, [{
        type: Component,
        args: [{
                selector: 'vm-submenu',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: SubmenuInputs,
                outputs: SubmenuOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Time, [{
        type: Component,
        args: [{
                selector: 'vm-time',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: TimeInputs,
                outputs: TimeOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TimeProgress, [{
        type: Component,
        args: [{
                selector: 'vm-time-progress',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: TimeProgressInputs,
                outputs: TimeProgressOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Tooltip, [{
        type: Component,
        args: [{
                selector: 'vm-tooltip',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: TooltipInputs,
                outputs: TooltipOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Ui, [{
        type: Component,
        args: [{
                selector: 'vm-ui',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: UiInputs,
                outputs: UiOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Video, [{
        type: Component,
        args: [{
                selector: 'vm-video',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: VideoInputs,
                outputs: VideoOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Vimeo, [{
        type: Component,
        args: [{
                selector: 'vm-vimeo',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: VimeoInputs,
                outputs: VimeoOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(VolumeControl, [{
        type: Component,
        args: [{
                selector: 'vm-volume-control',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: VolumeControlInputs,
                outputs: VolumeControlOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Youtube, [{
        type: Component,
        args: [{
                selector: 'vm-youtube',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: YoutubeInputs,
                outputs: YoutubeOutputs
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, null); })();

/* eslint-disable */

class VimeComponent {
    constructor(playerProps) {
        this.playerProps = playerProps;
        this.playerDispatch = () => { };
        this.unbindPlayerContext = () => { };
        this.playerCache = new Map();
        playerProps.forEach(prop => {
            this.playerCache.set(prop, this[prop]);
        });
        const props = playerProps.reduce((prev, prop) => (Object.assign(Object.assign({}, prev), { [prop]: {
                get() {
                    return this.playerCache.get(prop);
                },
                set: (value) => {
                    if (this.playerCache.get(prop) !== value) {
                        this.playerDispatch(prop, value);
                        this.playerCache.set(prop, value);
                    }
                },
            } })), {});
        Object.defineProperties(this, props);
    }
    ngAfterViewInit() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.ref.nativeElement)
                return;
            this.player = yield findPlayer(this.ref.nativeElement);
            if (!this.player)
                return;
            this.playerDispatch = createDispatcher(this.ref.nativeElement);
            this.unbindPlayerContext = yield usePlayerContext(this.ref.nativeElement, this.playerProps, (prop, value) => {
                this.playerCache.set(prop, value);
                this[prop] = value;
            }, this.player);
        });
    }
    ngOnDestroy() {
        var _a;
        (_a = this.unbindPlayerContext) === null || _a === void 0 ? void 0 : _a.call(this);
        this.playerCache.clear();
    }
}
VimeComponent.ɵfac = function VimeComponent_Factory(t) { return new (t || VimeComponent)(ɵngcc0.ɵɵinject(Array)); };
VimeComponent.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: VimeComponent, factory: VimeComponent.ɵfac });
VimeComponent.ctorParameters = () => [
    { type: Array }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(VimeComponent, [{
        type: Injectable
    }], function () { return [{ type: Array }]; }, null); })();

/* eslint-disable */
const DECLARATIONS = [
    Audio,
    CaptionControl,
    Captions,
    ClickToPlay,
    Control,
    ControlGroup,
    ControlSpacer,
    Controls,
    CurrentTime,
    Dailymotion,
    Dash,
    DblClickFullscreen,
    DefaultControls,
    DefaultSettings,
    DefaultUi,
    Embed,
    EndTime,
    File,
    FullscreenControl,
    Hls,
    Icon,
    IconLibrary,
    LiveIndicator,
    LoadingScreen,
    Menu,
    MenuItem,
    MenuRadio,
    MenuRadioGroup,
    MuteControl,
    PipControl,
    PlaybackControl,
    Player,
    Poster,
    Scrim,
    ScrubberControl,
    Settings,
    SettingsControl,
    Skeleton,
    Slider,
    Spinner,
    Submenu,
    Time,
    TimeProgress,
    Tooltip,
    Ui,
    Video,
    Vimeo,
    VolumeControl,
    Youtube,
];
class VimeModule {
}
VimeModule.ɵfac = function VimeModule_Factory(t) { return new (t || VimeModule)(); };
VimeModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: VimeModule });
VimeModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(VimeModule, [{
        type: NgModule,
        args: [{
                declarations: DECLARATIONS,
                exports: DECLARATIONS,
                imports: [],
                providers: []
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(VimeModule, { declarations: [Audio, CaptionControl, Captions, ClickToPlay, Control, ControlGroup, ControlSpacer, Controls, CurrentTime, Dailymotion, Dash, DblClickFullscreen, DefaultControls, DefaultSettings, DefaultUi, Embed, EndTime, File, FullscreenControl, Hls, Icon, IconLibrary, LiveIndicator, LoadingScreen, Menu, MenuItem, MenuRadio, MenuRadioGroup, MuteControl, PipControl, PlaybackControl, Player, Poster, Scrim, ScrubberControl, Settings, SettingsControl, Skeleton, Slider, Spinner, Submenu, Time, TimeProgress, Tooltip, Ui, Video, Vimeo, VolumeControl, Youtube], exports: [Audio, CaptionControl, Captions, ClickToPlay, Control, ControlGroup, ControlSpacer, Controls, CurrentTime, Dailymotion, Dash, DblClickFullscreen, DefaultControls, DefaultSettings, DefaultUi, Embed, EndTime, File, FullscreenControl, Hls, Icon, IconLibrary, LiveIndicator, LoadingScreen, Menu, MenuItem, MenuRadio, MenuRadioGroup, MuteControl, PipControl, PlaybackControl, Player, Poster, Scrim, ScrubberControl, Settings, SettingsControl, Skeleton, Slider, Spinner, Submenu, Time, TimeProgress, Tooltip, Ui, Video, Vimeo, VolumeControl, Youtube] }); })();

/**
 * Generated bundle index. Do not edit.
 */

export { Audio, CaptionControl, Captions, ClickToPlay, Control, ControlGroup, ControlSpacer, Controls, CurrentTime, Dailymotion, Dash, DblClickFullscreen, DefaultControls, DefaultSettings, DefaultUi, Embed, EndTime, File, FullscreenControl, Hls, Icon, IconLibrary, LiveIndicator, LoadingScreen, Menu, MenuItem, MenuRadio, MenuRadioGroup, MuteControl, PipControl, PlaybackControl, Player, Poster, Scrim, ScrubberControl, Settings, SettingsControl, Skeleton, Slider, Spinner, Submenu, Time, TimeProgress, Tooltip, Ui, Video, VimeComponent, VimeModule, Vimeo, VolumeControl, Youtube };

//# sourceMappingURL=vime-angular.js.map