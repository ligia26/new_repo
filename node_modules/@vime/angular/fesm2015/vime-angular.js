import { VmAudio, VmFile, VmCaptionControl, VmControl, VmIcon, VmTooltip, VmCaptions, VmClickToPlay, VmControlGroup, VmControlSpacer, VmControls, VmCurrentTime, VmTime, VmDailymotion, VmEmbed, VmDash, VmVideo, VmDblClickFullscreen, VmDefaultControls, VmEndTime, VmFullscreenControl, VmLiveIndicator, VmMuteControl, VmPipControl, VmPlaybackControl, VmScrim, VmScrubberControl, VmSlider, VmSettingsControl, VmTimeProgress, VmVolumeControl, VmDefaultSettings, VmMenu, VmMenuItem, VmMenuRadio, VmMenuRadioGroup, VmSettings, VmSubmenu, VmDefaultUi, VmLoadingScreen, VmPoster, VmSpinner, VmUi, VmHls, VmIconLibrary, VmPlayer, VmSkeleton, VmVimeo, VmYoutube, findPlayer, createDispatcher, usePlayerContext } from '@vime/core';
export { MediaType, Provider, ViewType, watchComponentRegistry } from '@vime/core';
import { __decorate, __awaiter } from 'tslib';
import { EventEmitter, Component, ChangeDetectionStrategy, ChangeDetectorRef, ElementRef, NgZone, Injectable, NgModule } from '@angular/core';

/* eslint-disable */
const define = (tagName, clazz) => {
    const isClient = typeof window !== 'undefined';
    if (isClient && !customElements.get(tagName))
        customElements.define(tagName, clazz);
};
const proxyInputs = (Component, inputs) => {
    const Prototype = Component.prototype;
    inputs.forEach(input => {
        Object.defineProperty(Prototype, input, {
            get() {
                return this.el[input];
            },
            set(val) {
                this.z.runOutsideAngular(() => (this.el[input] = val));
            },
        });
    });
};
const proxyMethods = (Component, methods) => {
    const Prototype = Component.prototype;
    methods.forEach(methodName => {
        Prototype[methodName] = function () {
            const args = arguments;
            return this.z.runOutsideAngular(() => this.el[methodName].apply(this.el, args));
        };
    });
};
const initOutputs = (instance, events) => {
    events.forEach(eventName => (instance[eventName] = new EventEmitter()));
};
function ProxyCmp(opts) {
    return function (Component) {
        if (opts.inputs)
            proxyInputs(Component, opts.inputs);
        if (opts.methods)
            proxyMethods(Component, opts.methods);
        return Component;
    };
}

const AudioInputs = [
    'willAttach',
    'crossOrigin',
    'preload',
    'disableRemotePlayback',
    'mediaTitle',
];
const AudioMethods = [
    'getAdapter',
];
const AudioOutputs = [];
let Audio = class Audio {
    constructor(c, r, z) {
        this.z = z;
        define('vm-audio', VmAudio);
        define('vm-file', VmFile);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
Audio.decorators = [
    { type: Component, args: [{
                selector: 'vm-audio',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: AudioInputs,
                outputs: AudioOutputs
            },] }
];
Audio.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Audio = __decorate([
    ProxyCmp({
        inputs: AudioInputs,
        methods: AudioMethods,
    })
], Audio);

const CaptionControlInputs = [
    'showIcon',
    'hideIcon',
    'tooltipPosition',
    'tooltipDirection',
    'hideTooltip',
    'icons',
    'keys',
    'i18n',
    'playbackReady',
    'textTracks',
    'isTextTrackVisible',
];
const CaptionControlMethods = [];
const CaptionControlOutputs = [];
let CaptionControl = class CaptionControl {
    constructor(c, r, z) {
        this.z = z;
        define('vm-caption-control', VmCaptionControl);
        define('vm-control', VmControl);
        define('vm-icon', VmIcon);
        define('vm-tooltip', VmTooltip);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
CaptionControl.decorators = [
    { type: Component, args: [{
                selector: 'vm-caption-control',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: CaptionControlInputs,
                outputs: CaptionControlOutputs
            },] }
];
CaptionControl.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
CaptionControl = __decorate([
    ProxyCmp({
        inputs: CaptionControlInputs,
        methods: CaptionControlMethods,
    })
], CaptionControl);

const CaptionsInputs = [
    'hidden',
    'isControlsActive',
    'isVideoView',
    'playbackStarted',
    'textTracks',
    'currentTextTrack',
    'isTextTrackVisible',
];
const CaptionsMethods = [];
const CaptionsOutputs = [];
let Captions = class Captions {
    constructor(c, r, z) {
        this.z = z;
        define('vm-captions', VmCaptions);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
Captions.decorators = [
    { type: Component, args: [{
                selector: 'vm-captions',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: CaptionsInputs,
                outputs: CaptionsOutputs
            },] }
];
Captions.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Captions = __decorate([
    ProxyCmp({
        inputs: CaptionsInputs,
        methods: CaptionsMethods,
    })
], Captions);

const ClickToPlayInputs = [
    'useOnMobile',
    'paused',
    'isVideoView',
    'isMobile',
];
const ClickToPlayMethods = [
    'forceClick',
];
const ClickToPlayOutputs = [];
let ClickToPlay = class ClickToPlay {
    constructor(c, r, z) {
        this.z = z;
        define('vm-click-to-play', VmClickToPlay);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
ClickToPlay.decorators = [
    { type: Component, args: [{
                selector: 'vm-click-to-play',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: ClickToPlayInputs,
                outputs: ClickToPlayOutputs
            },] }
];
ClickToPlay.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
ClickToPlay = __decorate([
    ProxyCmp({
        inputs: ClickToPlayInputs,
        methods: ClickToPlayMethods,
    })
], ClickToPlay);

const ControlInputs = [
    'keys',
    'identifier',
    'hidden',
    'label',
    'menu',
    'expanded',
    'pressed',
    'isTouch',
];
const ControlMethods = [
    'focusControl',
    'blurControl',
];
const ControlOutputs = [
    'vmInteractionChange',
    'vmFocus',
    'vmBlur',
];
let Control = class Control {
    constructor(c, r, z) {
        this.z = z;
        define('vm-control', VmControl);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmInteractionChange', 'vmFocus', 'vmBlur']);
    }
};
Control.decorators = [
    { type: Component, args: [{
                selector: 'vm-control',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: ControlInputs,
                outputs: ControlOutputs
            },] }
];
Control.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Control = __decorate([
    ProxyCmp({
        inputs: ControlInputs,
        methods: ControlMethods,
    })
], Control);

const ControlGroupInputs = [
    'space',
];
const ControlGroupMethods = [];
const ControlGroupOutputs = [];
let ControlGroup = class ControlGroup {
    constructor(c, r, z) {
        this.z = z;
        define('vm-control-group', VmControlGroup);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
ControlGroup.decorators = [
    { type: Component, args: [{
                selector: 'vm-control-group',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: ControlGroupInputs,
                outputs: ControlGroupOutputs
            },] }
];
ControlGroup.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
ControlGroup = __decorate([
    ProxyCmp({
        inputs: ControlGroupInputs,
        methods: ControlGroupMethods,
    })
], ControlGroup);

const ControlSpacerInputs = [];
const ControlSpacerMethods = [];
const ControlSpacerOutputs = [];
let ControlSpacer = class ControlSpacer {
    constructor(c, r, z) {
        this.z = z;
        define('vm-control-spacer', VmControlSpacer);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
ControlSpacer.decorators = [
    { type: Component, args: [{
                selector: 'vm-control-spacer',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: ControlSpacerInputs,
                outputs: ControlSpacerOutputs
            },] }
];
ControlSpacer.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
ControlSpacer = __decorate([
    ProxyCmp({
        inputs: ControlSpacerInputs,
        methods: ControlSpacerMethods,
    })
], ControlSpacer);

const ControlsInputs = [
    'hidden',
    'fullWidth',
    'fullHeight',
    'direction',
    'align',
    'justify',
    'pin',
    'activeDuration',
    'waitForPlaybackStart',
    'hideWhenPaused',
    'hideOnMouseLeave',
    'isAudioView',
    'isSettingsActive',
    'playbackReady',
    'isControlsActive',
    'paused',
    'playbackStarted',
];
const ControlsMethods = [];
const ControlsOutputs = [];
let Controls = class Controls {
    constructor(c, r, z) {
        this.z = z;
        define('vm-controls', VmControls);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
Controls.decorators = [
    { type: Component, args: [{
                selector: 'vm-controls',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: ControlsInputs,
                outputs: ControlsOutputs
            },] }
];
Controls.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Controls = __decorate([
    ProxyCmp({
        inputs: ControlsInputs,
        methods: ControlsMethods,
    })
], Controls);

const CurrentTimeInputs = [
    'currentTime',
    'i18n',
    'alwaysShowHours',
];
const CurrentTimeMethods = [];
const CurrentTimeOutputs = [];
let CurrentTime = class CurrentTime {
    constructor(c, r, z) {
        this.z = z;
        define('vm-current-time', VmCurrentTime);
        define('vm-time', VmTime);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
CurrentTime.decorators = [
    { type: Component, args: [{
                selector: 'vm-current-time',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: CurrentTimeInputs,
                outputs: CurrentTimeOutputs
            },] }
];
CurrentTime.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
CurrentTime = __decorate([
    ProxyCmp({
        inputs: CurrentTimeInputs,
        methods: CurrentTimeMethods,
    })
], CurrentTime);

const DailymotionInputs = [
    'videoId',
    'shouldAutoplayQueue',
    'showUpNextQueue',
    'showShareButtons',
    'color',
    'syndication',
    'showDailymotionLogo',
    'showVideoInfo',
    'language',
    'autoplay',
    'controls',
    'poster',
    'logger',
    'loop',
    'muted',
    'playsinline',
];
const DailymotionMethods = [
    'getAdapter',
];
const DailymotionOutputs = [
    'vmError',
];
let Dailymotion = class Dailymotion {
    constructor(c, r, z) {
        this.z = z;
        define('vm-dailymotion', VmDailymotion);
        define('vm-embed', VmEmbed);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmError']);
    }
};
Dailymotion.decorators = [
    { type: Component, args: [{
                selector: 'vm-dailymotion',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: DailymotionInputs,
                outputs: DailymotionOutputs
            },] }
];
Dailymotion.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Dailymotion = __decorate([
    ProxyCmp({
        inputs: DailymotionInputs,
        methods: DailymotionMethods,
    })
], Dailymotion);

const DashInputs = [
    'src',
    'version',
    'libSrc',
    'config',
    'autoplay',
    'crossOrigin',
    'preload',
    'poster',
    'controlsList',
    'autoPiP',
    'disablePiP',
    'disableRemotePlayback',
    'mediaTitle',
    'enableTextTracksByDefault',
    'shouldRenderNativeTextTracks',
    'isTextTrackVisible',
    'currentTextTrack',
];
const DashMethods = [
    'getAdapter',
];
const DashOutputs = [
    'vmError',
];
let Dash = class Dash {
    constructor(c, r, z) {
        this.z = z;
        define('vm-dash', VmDash);
        define('vm-file', VmFile);
        define('vm-video', VmVideo);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmError']);
    }
};
Dash.decorators = [
    { type: Component, args: [{
                selector: 'vm-dash',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: DashInputs,
                outputs: DashOutputs
            },] }
];
Dash.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Dash = __decorate([
    ProxyCmp({
        inputs: DashInputs,
        methods: DashMethods,
    })
], Dash);

const DblClickFullscreenInputs = [
    'useOnMobile',
    'isFullscreenActive',
    'isVideoView',
    'playbackReady',
    'isMobile',
];
const DblClickFullscreenMethods = [];
const DblClickFullscreenOutputs = [];
let DblClickFullscreen = class DblClickFullscreen {
    constructor(c, r, z) {
        this.z = z;
        define('vm-dbl-click-fullscreen', VmDblClickFullscreen);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
DblClickFullscreen.decorators = [
    { type: Component, args: [{
                selector: 'vm-dbl-click-fullscreen',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: DblClickFullscreenInputs,
                outputs: DblClickFullscreenOutputs
            },] }
];
DblClickFullscreen.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
DblClickFullscreen = __decorate([
    ProxyCmp({
        inputs: DblClickFullscreenInputs,
        methods: DblClickFullscreenMethods,
    })
], DblClickFullscreen);

const DefaultControlsInputs = [
    'activeDuration',
    'waitForPlaybackStart',
    'hideWhenPaused',
    'hideOnMouseLeave',
    'theme',
    'isMobile',
    'isLive',
    'isAudioView',
    'isVideoView',
];
const DefaultControlsMethods = [];
const DefaultControlsOutputs = [];
let DefaultControls = class DefaultControls {
    constructor(c, r, z) {
        this.z = z;
        define('vm-default-controls', VmDefaultControls);
        define('vm-caption-control', VmCaptionControl);
        define('vm-control', VmControl);
        define('vm-icon', VmIcon);
        define('vm-tooltip', VmTooltip);
        define('vm-control-group', VmControlGroup);
        define('vm-control-spacer', VmControlSpacer);
        define('vm-controls', VmControls);
        define('vm-current-time', VmCurrentTime);
        define('vm-time', VmTime);
        define('vm-end-time', VmEndTime);
        define('vm-fullscreen-control', VmFullscreenControl);
        define('vm-live-indicator', VmLiveIndicator);
        define('vm-mute-control', VmMuteControl);
        define('vm-pip-control', VmPipControl);
        define('vm-playback-control', VmPlaybackControl);
        define('vm-scrim', VmScrim);
        define('vm-scrubber-control', VmScrubberControl);
        define('vm-slider', VmSlider);
        define('vm-settings-control', VmSettingsControl);
        define('vm-time-progress', VmTimeProgress);
        define('vm-volume-control', VmVolumeControl);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
DefaultControls.decorators = [
    { type: Component, args: [{
                selector: 'vm-default-controls',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: DefaultControlsInputs,
                outputs: DefaultControlsOutputs
            },] }
];
DefaultControls.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
DefaultControls = __decorate([
    ProxyCmp({
        inputs: DefaultControlsInputs,
        methods: DefaultControlsMethods,
    })
], DefaultControls);

const DefaultSettingsInputs = [
    'pin',
    'i18n',
    'playbackReady',
    'playbackRate',
    'playbackRates',
    'isVideoView',
    'playbackQuality',
    'playbackQualities',
    'textTracks',
    'currentTextTrack',
    'audioTracks',
    'currentAudioTrack',
    'isTextTrackVisible',
];
const DefaultSettingsMethods = [];
const DefaultSettingsOutputs = [];
let DefaultSettings = class DefaultSettings {
    constructor(c, r, z) {
        this.z = z;
        define('vm-default-settings', VmDefaultSettings);
        define('vm-icon', VmIcon);
        define('vm-menu', VmMenu);
        define('vm-menu-item', VmMenuItem);
        define('vm-menu-radio', VmMenuRadio);
        define('vm-menu-radio-group', VmMenuRadioGroup);
        define('vm-settings', VmSettings);
        define('vm-submenu', VmSubmenu);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
DefaultSettings.decorators = [
    { type: Component, args: [{
                selector: 'vm-default-settings',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: DefaultSettingsInputs,
                outputs: DefaultSettingsOutputs
            },] }
];
DefaultSettings.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
DefaultSettings = __decorate([
    ProxyCmp({
        inputs: DefaultSettingsInputs,
        methods: DefaultSettingsMethods,
    })
], DefaultSettings);

const DefaultUiInputs = [
    'noClickToPlay',
    'noDblClickFullscreen',
    'noCaptions',
    'noPoster',
    'noSpinner',
    'noControls',
    'noSettings',
    'noLoadingScreen',
];
const DefaultUiMethods = [];
const DefaultUiOutputs = [];
let DefaultUi = class DefaultUi {
    constructor(c, r, z) {
        this.z = z;
        define('vm-default-ui', VmDefaultUi);
        define('vm-caption-control', VmCaptionControl);
        define('vm-control', VmControl);
        define('vm-icon', VmIcon);
        define('vm-tooltip', VmTooltip);
        define('vm-captions', VmCaptions);
        define('vm-click-to-play', VmClickToPlay);
        define('vm-control-group', VmControlGroup);
        define('vm-control-spacer', VmControlSpacer);
        define('vm-controls', VmControls);
        define('vm-current-time', VmCurrentTime);
        define('vm-time', VmTime);
        define('vm-dbl-click-fullscreen', VmDblClickFullscreen);
        define('vm-default-controls', VmDefaultControls);
        define('vm-end-time', VmEndTime);
        define('vm-fullscreen-control', VmFullscreenControl);
        define('vm-live-indicator', VmLiveIndicator);
        define('vm-mute-control', VmMuteControl);
        define('vm-pip-control', VmPipControl);
        define('vm-playback-control', VmPlaybackControl);
        define('vm-scrim', VmScrim);
        define('vm-scrubber-control', VmScrubberControl);
        define('vm-slider', VmSlider);
        define('vm-settings-control', VmSettingsControl);
        define('vm-time-progress', VmTimeProgress);
        define('vm-volume-control', VmVolumeControl);
        define('vm-default-settings', VmDefaultSettings);
        define('vm-menu', VmMenu);
        define('vm-menu-item', VmMenuItem);
        define('vm-menu-radio', VmMenuRadio);
        define('vm-menu-radio-group', VmMenuRadioGroup);
        define('vm-settings', VmSettings);
        define('vm-submenu', VmSubmenu);
        define('vm-loading-screen', VmLoadingScreen);
        define('vm-poster', VmPoster);
        define('vm-spinner', VmSpinner);
        define('vm-ui', VmUi);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
DefaultUi.decorators = [
    { type: Component, args: [{
                selector: 'vm-default-ui',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: DefaultUiInputs,
                outputs: DefaultUiOutputs
            },] }
];
DefaultUi.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
DefaultUi = __decorate([
    ProxyCmp({
        inputs: DefaultUiInputs,
        methods: DefaultUiMethods,
    })
], DefaultUi);

const EmbedInputs = [
    'embedSrc',
    'mediaTitle',
    'params',
    'origin',
    'preconnections',
    'decoder',
];
const EmbedMethods = [
    'postMessage',
];
const EmbedOutputs = [
    'vmEmbedSrcChange',
    'vmEmbedMessage',
    'vmEmbedLoaded',
];
let Embed = class Embed {
    constructor(c, r, z) {
        this.z = z;
        define('vm-embed', VmEmbed);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmEmbedSrcChange', 'vmEmbedMessage', 'vmEmbedLoaded']);
    }
};
Embed.decorators = [
    { type: Component, args: [{
                selector: 'vm-embed',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: EmbedInputs,
                outputs: EmbedOutputs
            },] }
];
Embed.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Embed = __decorate([
    ProxyCmp({
        inputs: EmbedInputs,
        methods: EmbedMethods,
    })
], Embed);

const EndTimeInputs = [
    'duration',
    'i18n',
    'alwaysShowHours',
];
const EndTimeMethods = [];
const EndTimeOutputs = [];
let EndTime = class EndTime {
    constructor(c, r, z) {
        this.z = z;
        define('vm-end-time', VmEndTime);
        define('vm-time', VmTime);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
EndTime.decorators = [
    { type: Component, args: [{
                selector: 'vm-end-time',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: EndTimeInputs,
                outputs: EndTimeOutputs
            },] }
];
EndTime.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
EndTime = __decorate([
    ProxyCmp({
        inputs: EndTimeInputs,
        methods: EndTimeMethods,
    })
], EndTime);

const FileInputs = [
    'willAttach',
    'crossOrigin',
    'preload',
    'poster',
    'mediaTitle',
    'controlsList',
    'autoPiP',
    'disablePiP',
    'disableRemotePlayback',
    'viewType',
    'playbackRates',
    'language',
    'autoplay',
    'controls',
    'logger',
    'loop',
    'muted',
    'playsinline',
    'noConnect',
    'paused',
    'currentTime',
    'volume',
    'playbackReady',
    'playbackStarted',
    'currentTextTrack',
    'hasCustomTextManager',
    'isTextTrackVisible',
    'shouldRenderNativeTextTracks',
];
const FileMethods = [
    'getAdapter',
];
const FileOutputs = [
    'vmError',
    'vmMediaElChange',
    'vmSrcSetChange',
];
let File = class File {
    constructor(c, r, z) {
        this.z = z;
        define('vm-file', VmFile);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmError', 'vmMediaElChange', 'vmSrcSetChange']);
    }
};
File.decorators = [
    { type: Component, args: [{
                selector: 'vm-file',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: FileInputs,
                outputs: FileOutputs
            },] }
];
File.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
File = __decorate([
    ProxyCmp({
        inputs: FileInputs,
        methods: FileMethods,
    })
], File);

const FullscreenControlInputs = [
    'enterIcon',
    'exitIcon',
    'icons',
    'tooltipPosition',
    'tooltipDirection',
    'hideTooltip',
    'keys',
    'isFullscreenActive',
    'i18n',
    'playbackReady',
];
const FullscreenControlMethods = [];
const FullscreenControlOutputs = [];
let FullscreenControl = class FullscreenControl {
    constructor(c, r, z) {
        this.z = z;
        define('vm-fullscreen-control', VmFullscreenControl);
        define('vm-control', VmControl);
        define('vm-icon', VmIcon);
        define('vm-tooltip', VmTooltip);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
FullscreenControl.decorators = [
    { type: Component, args: [{
                selector: 'vm-fullscreen-control',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: FullscreenControlInputs,
                outputs: FullscreenControlOutputs
            },] }
];
FullscreenControl.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
FullscreenControl = __decorate([
    ProxyCmp({
        inputs: FullscreenControlInputs,
        methods: FullscreenControlMethods,
    })
], FullscreenControl);

const HlsInputs = [
    'version',
    'libSrc',
    'config',
    'crossOrigin',
    'preload',
    'poster',
    'controlsList',
    'autoPiP',
    'disablePiP',
    'disableRemotePlayback',
    'playbackReady',
    'mediaTitle',
];
const HlsMethods = [
    'getAdapter',
];
const HlsOutputs = [
    'vmError',
];
let Hls = class Hls {
    constructor(c, r, z) {
        this.z = z;
        define('vm-hls', VmHls);
        define('vm-file', VmFile);
        define('vm-video', VmVideo);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmError']);
    }
};
Hls.decorators = [
    { type: Component, args: [{
                selector: 'vm-hls',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: HlsInputs,
                outputs: HlsOutputs
            },] }
];
Hls.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Hls = __decorate([
    ProxyCmp({
        inputs: HlsInputs,
        methods: HlsMethods,
    })
], Hls);

const IconInputs = [
    'name',
    'src',
    'label',
    'library',
    'icons',
];
const IconMethods = [
    'redraw',
];
const IconOutputs = [
    'vmLoad',
    'vmError',
];
let Icon = class Icon {
    constructor(c, r, z) {
        this.z = z;
        define('vm-icon', VmIcon);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmLoad', 'vmError']);
    }
};
Icon.decorators = [
    { type: Component, args: [{
                selector: 'vm-icon',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: IconInputs,
                outputs: IconOutputs
            },] }
];
Icon.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Icon = __decorate([
    ProxyCmp({
        inputs: IconInputs,
        methods: IconMethods,
    })
], Icon);

const IconLibraryInputs = [
    'name',
    'resolver',
    'icons',
];
const IconLibraryMethods = [];
const IconLibraryOutputs = [];
let IconLibrary = class IconLibrary {
    constructor(c, r, z) {
        this.z = z;
        define('vm-icon-library', VmIconLibrary);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
IconLibrary.decorators = [
    { type: Component, args: [{
                selector: 'vm-icon-library',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: IconLibraryInputs,
                outputs: IconLibraryOutputs
            },] }
];
IconLibrary.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
IconLibrary = __decorate([
    ProxyCmp({
        inputs: IconLibraryInputs,
        methods: IconLibraryMethods,
    })
], IconLibrary);

const LiveIndicatorInputs = [
    'isLive',
    'i18n',
];
const LiveIndicatorMethods = [];
const LiveIndicatorOutputs = [];
let LiveIndicator = class LiveIndicator {
    constructor(c, r, z) {
        this.z = z;
        define('vm-live-indicator', VmLiveIndicator);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
LiveIndicator.decorators = [
    { type: Component, args: [{
                selector: 'vm-live-indicator',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: LiveIndicatorInputs,
                outputs: LiveIndicatorOutputs
            },] }
];
LiveIndicator.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
LiveIndicator = __decorate([
    ProxyCmp({
        inputs: LiveIndicatorInputs,
        methods: LiveIndicatorMethods,
    })
], LiveIndicator);

const LoadingScreenInputs = [
    'playbackReady',
    'hideDots',
];
const LoadingScreenMethods = [];
const LoadingScreenOutputs = [];
let LoadingScreen = class LoadingScreen {
    constructor(c, r, z) {
        this.z = z;
        define('vm-loading-screen', VmLoadingScreen);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
LoadingScreen.decorators = [
    { type: Component, args: [{
                selector: 'vm-loading-screen',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: LoadingScreenInputs,
                outputs: LoadingScreenOutputs
            },] }
];
LoadingScreen.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
LoadingScreen = __decorate([
    ProxyCmp({
        inputs: LoadingScreenInputs,
        methods: LoadingScreenMethods,
    })
], LoadingScreen);

const MenuInputs = [
    'active',
    'identifier',
    'controller',
    'slideInDirection',
];
const MenuMethods = [
    'focusMenu',
    'blurMenu',
    'getActiveMenuItem',
    'setActiveMenuItem',
    'calculateHeight',
];
const MenuOutputs = [
    'vmOpen',
    'vmClose',
    'vmFocus',
    'vmBlur',
    'vmActiveSubmenuChange',
    'vmActiveMenuItemChange',
    'vmMenuHeightChange',
];
let Menu = class Menu {
    constructor(c, r, z) {
        this.z = z;
        define('vm-menu', VmMenu);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmOpen', 'vmClose', 'vmFocus', 'vmBlur', 'vmActiveSubmenuChange', 'vmActiveMenuItemChange', 'vmMenuHeightChange']);
    }
};
Menu.decorators = [
    { type: Component, args: [{
                selector: 'vm-menu',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: MenuInputs,
                outputs: MenuOutputs
            },] }
];
Menu.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Menu = __decorate([
    ProxyCmp({
        inputs: MenuInputs,
        methods: MenuMethods,
    })
], Menu);

const MenuItemInputs = [
    'identifier',
    'hidden',
    'label',
    'menu',
    'expanded',
    'checked',
    'hint',
    'badge',
    'checkIcon',
    'icons',
    'isTouch',
];
const MenuItemMethods = [
    'focusItem',
    'blurItem',
    'getHeight',
];
const MenuItemOutputs = [
    'vmFocus',
    'vmBlur',
];
let MenuItem = class MenuItem {
    constructor(c, r, z) {
        this.z = z;
        define('vm-menu-item', VmMenuItem);
        define('vm-icon', VmIcon);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmFocus', 'vmBlur']);
    }
};
MenuItem.decorators = [
    { type: Component, args: [{
                selector: 'vm-menu-item',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: MenuItemInputs,
                outputs: MenuItemOutputs
            },] }
];
MenuItem.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
MenuItem = __decorate([
    ProxyCmp({
        inputs: MenuItemInputs,
        methods: MenuItemMethods,
    })
], MenuItem);

const MenuRadioInputs = [
    'label',
    'value',
    'checked',
    'badge',
    'checkIcon',
    'icons',
];
const MenuRadioMethods = [];
const MenuRadioOutputs = [
    'vmCheck',
];
let MenuRadio = class MenuRadio {
    constructor(c, r, z) {
        this.z = z;
        define('vm-menu-radio', VmMenuRadio);
        define('vm-icon', VmIcon);
        define('vm-menu-item', VmMenuItem);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmCheck']);
    }
};
MenuRadio.decorators = [
    { type: Component, args: [{
                selector: 'vm-menu-radio',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: MenuRadioInputs,
                outputs: MenuRadioOutputs
            },] }
];
MenuRadio.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
MenuRadio = __decorate([
    ProxyCmp({
        inputs: MenuRadioInputs,
        methods: MenuRadioMethods,
    })
], MenuRadio);

const MenuRadioGroupInputs = [
    'value',
];
const MenuRadioGroupMethods = [];
const MenuRadioGroupOutputs = [
    'vmCheck',
];
let MenuRadioGroup = class MenuRadioGroup {
    constructor(c, r, z) {
        this.z = z;
        define('vm-menu-radio-group', VmMenuRadioGroup);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmCheck']);
    }
};
MenuRadioGroup.decorators = [
    { type: Component, args: [{
                selector: 'vm-menu-radio-group',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: MenuRadioGroupInputs,
                outputs: MenuRadioGroupOutputs
            },] }
];
MenuRadioGroup.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
MenuRadioGroup = __decorate([
    ProxyCmp({
        inputs: MenuRadioGroupInputs,
        methods: MenuRadioGroupMethods,
    })
], MenuRadioGroup);

const MuteControlInputs = [
    'lowVolumeIcon',
    'highVolumeIcon',
    'mutedIcon',
    'icons',
    'tooltipPosition',
    'tooltipDirection',
    'hideTooltip',
    'keys',
    'volume',
    'muted',
    'i18n',
];
const MuteControlMethods = [];
const MuteControlOutputs = [
    'vmFocus',
    'vmBlur',
];
let MuteControl = class MuteControl {
    constructor(c, r, z) {
        this.z = z;
        define('vm-mute-control', VmMuteControl);
        define('vm-control', VmControl);
        define('vm-icon', VmIcon);
        define('vm-tooltip', VmTooltip);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmFocus', 'vmBlur']);
    }
};
MuteControl.decorators = [
    { type: Component, args: [{
                selector: 'vm-mute-control',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: MuteControlInputs,
                outputs: MuteControlOutputs
            },] }
];
MuteControl.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
MuteControl = __decorate([
    ProxyCmp({
        inputs: MuteControlInputs,
        methods: MuteControlMethods,
    })
], MuteControl);

const PipControlInputs = [
    'enterIcon',
    'exitIcon',
    'icons',
    'tooltipPosition',
    'tooltipDirection',
    'hideTooltip',
    'keys',
    'isPiPActive',
    'i18n',
    'playbackReady',
];
const PipControlMethods = [];
const PipControlOutputs = [];
let PipControl = class PipControl {
    constructor(c, r, z) {
        this.z = z;
        define('vm-pip-control', VmPipControl);
        define('vm-control', VmControl);
        define('vm-icon', VmIcon);
        define('vm-tooltip', VmTooltip);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
PipControl.decorators = [
    { type: Component, args: [{
                selector: 'vm-pip-control',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: PipControlInputs,
                outputs: PipControlOutputs
            },] }
];
PipControl.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
PipControl = __decorate([
    ProxyCmp({
        inputs: PipControlInputs,
        methods: PipControlMethods,
    })
], PipControl);

const PlaybackControlInputs = [
    'playIcon',
    'pauseIcon',
    'icons',
    'tooltipPosition',
    'tooltipDirection',
    'hideTooltip',
    'keys',
    'paused',
    'i18n',
];
const PlaybackControlMethods = [];
const PlaybackControlOutputs = [];
let PlaybackControl = class PlaybackControl {
    constructor(c, r, z) {
        this.z = z;
        define('vm-playback-control', VmPlaybackControl);
        define('vm-control', VmControl);
        define('vm-icon', VmIcon);
        define('vm-tooltip', VmTooltip);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
PlaybackControl.decorators = [
    { type: Component, args: [{
                selector: 'vm-playback-control',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: PlaybackControlInputs,
                outputs: PlaybackControlOutputs
            },] }
];
PlaybackControl.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
PlaybackControl = __decorate([
    ProxyCmp({
        inputs: PlaybackControlInputs,
        methods: PlaybackControlMethods,
    })
], PlaybackControl);

const PlayerInputs = [
    'logger',
    'theme',
    'icons',
    'paused',
    'playing',
    'duration',
    'mediaTitle',
    'currentProvider',
    'currentSrc',
    'currentPoster',
    'currentTime',
    'autoplay',
    'ready',
    'playbackReady',
    'loop',
    'muted',
    'buffered',
    'playbackRate',
    'playbackRates',
    'playbackQuality',
    'playbackQualities',
    'seeking',
    'debug',
    'playbackStarted',
    'playbackEnded',
    'buffering',
    'controls',
    'isControlsActive',
    'isSettingsActive',
    'volume',
    'isFullscreenActive',
    'aspectRatio',
    'viewType',
    'isAudioView',
    'isVideoView',
    'mediaType',
    'isAudio',
    'isVideo',
    'isLive',
    'isMobile',
    'isTouch',
    'isPiPActive',
    'textTracks',
    'currentTextTrack',
    'isTextTrackVisible',
    'shouldRenderNativeTextTracks',
    'audioTracks',
    'currentAudioTrack',
    'autopause',
    'playsinline',
    'language',
    'translations',
    'languages',
    'i18n',
];
const PlayerMethods = [
    'getProvider',
    'getAdapter',
    'play',
    'pause',
    'canPlay',
    'canAutoplay',
    'canMutedAutoplay',
    'canSetPlaybackRate',
    'canSetPlaybackQuality',
    'canSetFullscreen',
    'enterFullscreen',
    'exitFullscreen',
    'canSetPiP',
    'enterPiP',
    'exitPiP',
    'canSetAudioTrack',
    'setCurrentAudioTrack',
    'canSetTextTrack',
    'setCurrentTextTrack',
    'canSetTextTrackVisibility',
    'setTextTrackVisibility',
    'extendLanguage',
    'getContainer',
    'callAdapter',
];
const PlayerOutputs = [
    'vmThemeChange',
    'vmPausedChange',
    'vmPlay',
    'vmPlayingChange',
    'vmSeekingChange',
    'vmSeeked',
    'vmBufferingChange',
    'vmDurationChange',
    'vmCurrentTimeChange',
    'vmReady',
    'vmPlaybackReady',
    'vmPlaybackStarted',
    'vmPlaybackEnded',
    'vmBufferedChange',
    'vmError',
    'vmLoadStart',
    'vmCurrentProviderChange',
    'vmCurrentSrcChange',
    'vmCurrentPosterChange',
    'vmMediaTitleChange',
    'vmControlsChange',
    'vmPlaybackRateChange',
    'vmPlaybackRatesChange',
    'vmPlaybackQualityChange',
    'vmPlaybackQualitiesChange',
    'vmMutedChange',
    'vmVolumeChange',
    'vmViewTypeChange',
    'vmMediaTypeChange',
    'vmLiveChange',
    'vmTouchChange',
    'vmLanguageChange',
    'vmI18nChange',
    'vmTranslationsChange',
    'vmLanguagesChange',
    'vmFullscreenChange',
    'vmPiPChange',
    'vmTextTracksChange',
    'vmCurrentTextTrackChange',
    'vmTextTrackVisibleChange',
    'vmAudioTracksChange',
    'vmCurrentAudioTrackChange',
];
let Player = class Player {
    constructor(c, r, z) {
        this.z = z;
        define('vm-player', VmPlayer);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmThemeChange', 'vmPausedChange', 'vmPlay', 'vmPlayingChange', 'vmSeekingChange', 'vmSeeked', 'vmBufferingChange', 'vmDurationChange', 'vmCurrentTimeChange', 'vmReady', 'vmPlaybackReady', 'vmPlaybackStarted', 'vmPlaybackEnded', 'vmBufferedChange', 'vmError', 'vmLoadStart', 'vmCurrentProviderChange', 'vmCurrentSrcChange', 'vmCurrentPosterChange', 'vmMediaTitleChange', 'vmControlsChange', 'vmPlaybackRateChange', 'vmPlaybackRatesChange', 'vmPlaybackQualityChange', 'vmPlaybackQualitiesChange', 'vmMutedChange', 'vmVolumeChange', 'vmViewTypeChange', 'vmMediaTypeChange', 'vmLiveChange', 'vmTouchChange', 'vmLanguageChange', 'vmI18nChange', 'vmTranslationsChange', 'vmLanguagesChange', 'vmFullscreenChange', 'vmPiPChange', 'vmTextTracksChange', 'vmCurrentTextTrackChange', 'vmTextTrackVisibleChange', 'vmAudioTracksChange', 'vmCurrentAudioTrackChange']);
    }
};
Player.decorators = [
    { type: Component, args: [{
                selector: 'vm-player',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: PlayerInputs,
                outputs: PlayerOutputs
            },] }
];
Player.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Player = __decorate([
    ProxyCmp({
        inputs: PlayerInputs,
        methods: PlayerMethods,
    })
], Player);

const PosterInputs = [
    'fit',
    'isVideoView',
    'currentPoster',
    'mediaTitle',
    'playbackStarted',
    'currentTime',
];
const PosterMethods = [];
const PosterOutputs = [
    'vmLoaded',
    'vmWillShow',
    'vmWillHide',
];
let Poster = class Poster {
    constructor(c, r, z) {
        this.z = z;
        define('vm-poster', VmPoster);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmLoaded', 'vmWillShow', 'vmWillHide']);
    }
};
Poster.decorators = [
    { type: Component, args: [{
                selector: 'vm-poster',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: PosterInputs,
                outputs: PosterOutputs
            },] }
];
Poster.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Poster = __decorate([
    ProxyCmp({
        inputs: PosterInputs,
        methods: PosterMethods,
    })
], Poster);

const ScrimInputs = [
    'gradient',
    'isVideoView',
    'isControlsActive',
];
const ScrimMethods = [];
const ScrimOutputs = [];
let Scrim = class Scrim {
    constructor(c, r, z) {
        this.z = z;
        define('vm-scrim', VmScrim);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
Scrim.decorators = [
    { type: Component, args: [{
                selector: 'vm-scrim',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: ScrimInputs,
                outputs: ScrimOutputs
            },] }
];
Scrim.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Scrim = __decorate([
    ProxyCmp({
        inputs: ScrimInputs,
        methods: ScrimMethods,
    })
], Scrim);

const ScrubberControlInputs = [
    'alwaysShowHours',
    'hideTooltip',
    'currentTime',
    'duration',
    'noKeyboard',
    'buffering',
    'buffered',
    'i18n',
];
const ScrubberControlMethods = [];
const ScrubberControlOutputs = [];
let ScrubberControl = class ScrubberControl {
    constructor(c, r, z) {
        this.z = z;
        define('vm-scrubber-control', VmScrubberControl);
        define('vm-slider', VmSlider);
        define('vm-tooltip', VmTooltip);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
ScrubberControl.decorators = [
    { type: Component, args: [{
                selector: 'vm-scrubber-control',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: ScrubberControlInputs,
                outputs: ScrubberControlOutputs
            },] }
];
ScrubberControl.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
ScrubberControl = __decorate([
    ProxyCmp({
        inputs: ScrubberControlInputs,
        methods: ScrubberControlMethods,
    })
], ScrubberControl);

const SettingsInputs = [
    'pin',
    'active',
    'isMobile',
    'isAudioView',
];
const SettingsMethods = [
    'setController',
];
const SettingsOutputs = [];
let Settings = class Settings {
    constructor(c, r, z) {
        this.z = z;
        define('vm-settings', VmSettings);
        define('vm-menu', VmMenu);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
Settings.decorators = [
    { type: Component, args: [{
                selector: 'vm-settings',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: SettingsInputs,
                outputs: SettingsOutputs
            },] }
];
Settings.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Settings = __decorate([
    ProxyCmp({
        inputs: SettingsInputs,
        methods: SettingsMethods,
    })
], Settings);

const SettingsControlInputs = [
    'icon',
    'icons',
    'tooltipPosition',
    'tooltipDirection',
    'menu',
    'expanded',
    'i18n',
    'hideTooltip',
];
const SettingsControlMethods = [
    'focusControl',
    'blurControl',
];
const SettingsControlOutputs = [];
let SettingsControl = class SettingsControl {
    constructor(c, r, z) {
        this.z = z;
        define('vm-settings-control', VmSettingsControl);
        define('vm-control', VmControl);
        define('vm-icon', VmIcon);
        define('vm-tooltip', VmTooltip);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
SettingsControl.decorators = [
    { type: Component, args: [{
                selector: 'vm-settings-control',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: SettingsControlInputs,
                outputs: SettingsControlOutputs
            },] }
];
SettingsControl.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
SettingsControl = __decorate([
    ProxyCmp({
        inputs: SettingsControlInputs,
        methods: SettingsControlMethods,
    })
], SettingsControl);

const SkeletonInputs = [
    'effect',
    'ready',
];
const SkeletonMethods = [];
const SkeletonOutputs = [];
let Skeleton = class Skeleton {
    constructor(c, r, z) {
        this.z = z;
        define('vm-skeleton', VmSkeleton);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
Skeleton.decorators = [
    { type: Component, args: [{
                selector: 'vm-skeleton',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: SkeletonInputs,
                outputs: SkeletonOutputs
            },] }
];
Skeleton.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Skeleton = __decorate([
    ProxyCmp({
        inputs: SkeletonInputs,
        methods: SkeletonMethods,
    })
], Skeleton);

const SliderInputs = [
    'step',
    'min',
    'max',
    'value',
    'valueText',
    'label',
];
const SliderMethods = [];
const SliderOutputs = [
    'vmValueChange',
    'vmFocus',
    'vmBlur',
];
let Slider = class Slider {
    constructor(c, r, z) {
        this.z = z;
        define('vm-slider', VmSlider);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmValueChange', 'vmFocus', 'vmBlur']);
    }
};
Slider.decorators = [
    { type: Component, args: [{
                selector: 'vm-slider',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: SliderInputs,
                outputs: SliderOutputs
            },] }
];
Slider.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Slider = __decorate([
    ProxyCmp({
        inputs: SliderInputs,
        methods: SliderMethods,
    })
], Slider);

const SpinnerInputs = [
    'isVideoView',
    'currentProvider',
    'showWhenMediaLoading',
    'playbackReady',
    'buffering',
];
const SpinnerMethods = [];
const SpinnerOutputs = [
    'vmWillShow',
    'vmWillHide',
];
let Spinner = class Spinner {
    constructor(c, r, z) {
        this.z = z;
        define('vm-spinner', VmSpinner);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmWillShow', 'vmWillHide']);
    }
};
Spinner.decorators = [
    { type: Component, args: [{
                selector: 'vm-spinner',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: SpinnerInputs,
                outputs: SpinnerOutputs
            },] }
];
Spinner.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Spinner = __decorate([
    ProxyCmp({
        inputs: SpinnerInputs,
        methods: SpinnerMethods,
    })
], Spinner);

const SubmenuInputs = [
    'label',
    'hint',
    'slideInDirection',
    'active',
];
const SubmenuMethods = [
    'getController',
    'getMenu',
    'getControllerHeight',
];
const SubmenuOutputs = [
    'vmOpenSubmenu',
    'vmCloseSubmenu',
];
let Submenu = class Submenu {
    constructor(c, r, z) {
        this.z = z;
        define('vm-submenu', VmSubmenu);
        define('vm-icon', VmIcon);
        define('vm-menu', VmMenu);
        define('vm-menu-item', VmMenuItem);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmOpenSubmenu', 'vmCloseSubmenu']);
    }
};
Submenu.decorators = [
    { type: Component, args: [{
                selector: 'vm-submenu',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: SubmenuInputs,
                outputs: SubmenuOutputs
            },] }
];
Submenu.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Submenu = __decorate([
    ProxyCmp({
        inputs: SubmenuInputs,
        methods: SubmenuMethods,
    })
], Submenu);

const TimeInputs = [
    'label',
    'seconds',
    'alwaysShowHours',
];
const TimeMethods = [];
const TimeOutputs = [];
let Time = class Time {
    constructor(c, r, z) {
        this.z = z;
        define('vm-time', VmTime);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
Time.decorators = [
    { type: Component, args: [{
                selector: 'vm-time',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: TimeInputs,
                outputs: TimeOutputs
            },] }
];
Time.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Time = __decorate([
    ProxyCmp({
        inputs: TimeInputs,
        methods: TimeMethods,
    })
], Time);

const TimeProgressInputs = [
    'separator',
    'alwaysShowHours',
];
const TimeProgressMethods = [];
const TimeProgressOutputs = [];
let TimeProgress = class TimeProgress {
    constructor(c, r, z) {
        this.z = z;
        define('vm-time-progress', VmTimeProgress);
        define('vm-current-time', VmCurrentTime);
        define('vm-time', VmTime);
        define('vm-end-time', VmEndTime);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
TimeProgress.decorators = [
    { type: Component, args: [{
                selector: 'vm-time-progress',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: TimeProgressInputs,
                outputs: TimeProgressOutputs
            },] }
];
TimeProgress.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
TimeProgress = __decorate([
    ProxyCmp({
        inputs: TimeProgressInputs,
        methods: TimeProgressMethods,
    })
], TimeProgress);

const TooltipInputs = [
    'hidden',
    'active',
    'position',
    'direction',
    'isTouch',
    'isMobile',
];
const TooltipMethods = [];
const TooltipOutputs = [];
let Tooltip = class Tooltip {
    constructor(c, r, z) {
        this.z = z;
        define('vm-tooltip', VmTooltip);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
Tooltip.decorators = [
    { type: Component, args: [{
                selector: 'vm-tooltip',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: TooltipInputs,
                outputs: TooltipOutputs
            },] }
];
Tooltip.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Tooltip = __decorate([
    ProxyCmp({
        inputs: TooltipInputs,
        methods: TooltipMethods,
    })
], Tooltip);

const UiInputs = [
    'isVideoView',
    'playsinline',
    'isFullscreenActive',
];
const UiMethods = [];
const UiOutputs = [];
let Ui = class Ui {
    constructor(c, r, z) {
        this.z = z;
        define('vm-ui', VmUi);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
Ui.decorators = [
    { type: Component, args: [{
                selector: 'vm-ui',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: UiInputs,
                outputs: UiOutputs
            },] }
];
Ui.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Ui = __decorate([
    ProxyCmp({
        inputs: UiInputs,
        methods: UiMethods,
    })
], Ui);

const VideoInputs = [
    'willAttach',
    'hasCustomTextManager',
    'crossOrigin',
    'preload',
    'poster',
    'controlsList',
    'autoPiP',
    'disablePiP',
    'disableRemotePlayback',
    'mediaTitle',
];
const VideoMethods = [
    'getAdapter',
];
const VideoOutputs = [];
let Video = class Video {
    constructor(c, r, z) {
        this.z = z;
        define('vm-video', VmVideo);
        define('vm-file', VmFile);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
Video.decorators = [
    { type: Component, args: [{
                selector: 'vm-video',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: VideoInputs,
                outputs: VideoOutputs
            },] }
];
Video.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Video = __decorate([
    ProxyCmp({
        inputs: VideoInputs,
        methods: VideoMethods,
    })
], Video);

const VimeoInputs = [
    'videoId',
    'byline',
    'color',
    'portrait',
    'noAutoAspectRatio',
    'poster',
    'cookies',
    'language',
    'aspectRatio',
    'autoplay',
    'controls',
    'logger',
    'loop',
    'muted',
    'playsinline',
];
const VimeoMethods = [
    'getAdapter',
];
const VimeoOutputs = [
    'vmError',
];
let Vimeo = class Vimeo {
    constructor(c, r, z) {
        this.z = z;
        define('vm-vimeo', VmVimeo);
        define('vm-embed', VmEmbed);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmError']);
    }
};
Vimeo.decorators = [
    { type: Component, args: [{
                selector: 'vm-vimeo',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: VimeoInputs,
                outputs: VimeoOutputs
            },] }
];
Vimeo.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Vimeo = __decorate([
    ProxyCmp({
        inputs: VimeoInputs,
        methods: VimeoMethods,
    })
], Vimeo);

const VolumeControlInputs = [
    'lowVolumeIcon',
    'highVolumeIcon',
    'mutedIcon',
    'icons',
    'tooltipPosition',
    'tooltipDirection',
    'hideTooltip',
    'muteKeys',
    'noKeyboard',
    'muted',
    'volume',
    'isMobile',
    'i18n',
];
const VolumeControlMethods = [];
const VolumeControlOutputs = [];
let VolumeControl = class VolumeControl {
    constructor(c, r, z) {
        this.z = z;
        define('vm-volume-control', VmVolumeControl);
        define('vm-control', VmControl);
        define('vm-icon', VmIcon);
        define('vm-mute-control', VmMuteControl);
        define('vm-tooltip', VmTooltip);
        define('vm-slider', VmSlider);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
VolumeControl.decorators = [
    { type: Component, args: [{
                selector: 'vm-volume-control',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: VolumeControlInputs,
                outputs: VolumeControlOutputs
            },] }
];
VolumeControl.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
VolumeControl = __decorate([
    ProxyCmp({
        inputs: VolumeControlInputs,
        methods: VolumeControlMethods,
    })
], VolumeControl);

const YoutubeInputs = [
    'cookies',
    'videoId',
    'showFullscreenControl',
    'poster',
    'language',
    'autoplay',
    'controls',
    'logger',
    'loop',
    'muted',
    'playsinline',
];
const YoutubeMethods = [
    'getAdapter',
];
const YoutubeOutputs = [];
let Youtube = class Youtube {
    constructor(c, r, z) {
        this.z = z;
        define('vm-youtube', VmYoutube);
        define('vm-embed', VmEmbed);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, []);
    }
};
Youtube.decorators = [
    { type: Component, args: [{
                selector: 'vm-youtube',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: YoutubeInputs,
                outputs: YoutubeOutputs
            },] }
];
Youtube.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
Youtube = __decorate([
    ProxyCmp({
        inputs: YoutubeInputs,
        methods: YoutubeMethods,
    })
], Youtube);

/* eslint-disable */

class VimeComponent {
    constructor(playerProps) {
        this.playerProps = playerProps;
        this.playerDispatch = () => { };
        this.unbindPlayerContext = () => { };
        this.playerCache = new Map();
        playerProps.forEach(prop => {
            this.playerCache.set(prop, this[prop]);
        });
        const props = playerProps.reduce((prev, prop) => (Object.assign(Object.assign({}, prev), { [prop]: {
                get() {
                    return this.playerCache.get(prop);
                },
                set: (value) => {
                    if (this.playerCache.get(prop) !== value) {
                        this.playerDispatch(prop, value);
                        this.playerCache.set(prop, value);
                    }
                },
            } })), {});
        Object.defineProperties(this, props);
    }
    ngAfterViewInit() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.ref.nativeElement)
                return;
            this.player = yield findPlayer(this.ref.nativeElement);
            if (!this.player)
                return;
            this.playerDispatch = createDispatcher(this.ref.nativeElement);
            this.unbindPlayerContext = yield usePlayerContext(this.ref.nativeElement, this.playerProps, (prop, value) => {
                this.playerCache.set(prop, value);
                this[prop] = value;
            }, this.player);
        });
    }
    ngOnDestroy() {
        var _a;
        (_a = this.unbindPlayerContext) === null || _a === void 0 ? void 0 : _a.call(this);
        this.playerCache.clear();
    }
}
VimeComponent.decorators = [
    { type: Injectable }
];
VimeComponent.ctorParameters = () => [
    { type: Array }
];

/* eslint-disable */
const DECLARATIONS = [
    Audio,
    CaptionControl,
    Captions,
    ClickToPlay,
    Control,
    ControlGroup,
    ControlSpacer,
    Controls,
    CurrentTime,
    Dailymotion,
    Dash,
    DblClickFullscreen,
    DefaultControls,
    DefaultSettings,
    DefaultUi,
    Embed,
    EndTime,
    File,
    FullscreenControl,
    Hls,
    Icon,
    IconLibrary,
    LiveIndicator,
    LoadingScreen,
    Menu,
    MenuItem,
    MenuRadio,
    MenuRadioGroup,
    MuteControl,
    PipControl,
    PlaybackControl,
    Player,
    Poster,
    Scrim,
    ScrubberControl,
    Settings,
    SettingsControl,
    Skeleton,
    Slider,
    Spinner,
    Submenu,
    Time,
    TimeProgress,
    Tooltip,
    Ui,
    Video,
    Vimeo,
    VolumeControl,
    Youtube,
];
class VimeModule {
}
VimeModule.decorators = [
    { type: NgModule, args: [{
                declarations: DECLARATIONS,
                exports: DECLARATIONS,
                imports: [],
                providers: [],
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { Audio, CaptionControl, Captions, ClickToPlay, Control, ControlGroup, ControlSpacer, Controls, CurrentTime, Dailymotion, Dash, DblClickFullscreen, DefaultControls, DefaultSettings, DefaultUi, Embed, EndTime, File, FullscreenControl, Hls, Icon, IconLibrary, LiveIndicator, LoadingScreen, Menu, MenuItem, MenuRadio, MenuRadioGroup, MuteControl, PipControl, PlaybackControl, Player, Poster, Scrim, ScrubberControl, Settings, SettingsControl, Skeleton, Slider, Spinner, Submenu, Time, TimeProgress, Tooltip, Ui, Video, VimeComponent, VimeModule, Vimeo, VolumeControl, Youtube };
//# sourceMappingURL=vime-angular.js.map
