(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@vime/core'), require('@angular/core')) :
    typeof define === 'function' && define.amd ? define('@vime/angular', ['exports', '@vime/core', '@angular/core'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.vime = global.vime || {}, global.vime.angular = {}), global.Vime, global.ng.core));
})(this, (function (exports, core, core$1) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                    if (!ar)
                        ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
        return to.concat(ar || Array.prototype.slice.call(from));
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    /* eslint-disable */
    var define = function (tagName, clazz) {
        var isClient = typeof window !== 'undefined';
        if (isClient && !customElements.get(tagName))
            customElements.define(tagName, clazz);
    };
    var proxyInputs = function (Component, inputs) {
        var Prototype = Component.prototype;
        inputs.forEach(function (input) {
            Object.defineProperty(Prototype, input, {
                get: function () {
                    return this.el[input];
                },
                set: function (val) {
                    var _this = this;
                    this.z.runOutsideAngular(function () { return (_this.el[input] = val); });
                },
            });
        });
    };
    var proxyMethods = function (Component, methods) {
        var Prototype = Component.prototype;
        methods.forEach(function (methodName) {
            Prototype[methodName] = function () {
                var _this = this;
                var args = arguments;
                return this.z.runOutsideAngular(function () { return _this.el[methodName].apply(_this.el, args); });
            };
        });
    };
    var initOutputs = function (instance, events) {
        events.forEach(function (eventName) { return (instance[eventName] = new core$1.EventEmitter()); });
    };
    function ProxyCmp(opts) {
        return function (Component) {
            if (opts.inputs)
                proxyInputs(Component, opts.inputs);
            if (opts.methods)
                proxyMethods(Component, opts.methods);
            return Component;
        };
    }

    var AudioInputs = [
        'willAttach',
        'crossOrigin',
        'preload',
        'disableRemotePlayback',
        'mediaTitle',
    ];
    var AudioMethods = [
        'getAdapter',
    ];
    var AudioOutputs = [];
    exports.Audio = /** @class */ (function () {
        function Audio(c, r, z) {
            this.z = z;
            define('vm-audio', core.VmAudio);
            define('vm-file', core.VmFile);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, []);
        }
        return Audio;
    }());
    exports.Audio.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-audio',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: AudioInputs,
                    outputs: AudioOutputs
                },] }
    ];
    exports.Audio.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.Audio = __decorate([
        ProxyCmp({
            inputs: AudioInputs,
            methods: AudioMethods,
        })
    ], exports.Audio);

    var CaptionControlInputs = [
        'showIcon',
        'hideIcon',
        'tooltipPosition',
        'tooltipDirection',
        'hideTooltip',
        'icons',
        'keys',
        'i18n',
        'playbackReady',
        'textTracks',
        'isTextTrackVisible',
    ];
    var CaptionControlMethods = [];
    var CaptionControlOutputs = [];
    exports.CaptionControl = /** @class */ (function () {
        function CaptionControl(c, r, z) {
            this.z = z;
            define('vm-caption-control', core.VmCaptionControl);
            define('vm-control', core.VmControl);
            define('vm-icon', core.VmIcon);
            define('vm-tooltip', core.VmTooltip);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, []);
        }
        return CaptionControl;
    }());
    exports.CaptionControl.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-caption-control',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: CaptionControlInputs,
                    outputs: CaptionControlOutputs
                },] }
    ];
    exports.CaptionControl.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.CaptionControl = __decorate([
        ProxyCmp({
            inputs: CaptionControlInputs,
            methods: CaptionControlMethods,
        })
    ], exports.CaptionControl);

    var CaptionsInputs = [
        'hidden',
        'isControlsActive',
        'isVideoView',
        'playbackStarted',
        'textTracks',
        'currentTextTrack',
        'isTextTrackVisible',
    ];
    var CaptionsMethods = [];
    var CaptionsOutputs = [];
    exports.Captions = /** @class */ (function () {
        function Captions(c, r, z) {
            this.z = z;
            define('vm-captions', core.VmCaptions);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, []);
        }
        return Captions;
    }());
    exports.Captions.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-captions',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: CaptionsInputs,
                    outputs: CaptionsOutputs
                },] }
    ];
    exports.Captions.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.Captions = __decorate([
        ProxyCmp({
            inputs: CaptionsInputs,
            methods: CaptionsMethods,
        })
    ], exports.Captions);

    var ClickToPlayInputs = [
        'useOnMobile',
        'paused',
        'isVideoView',
        'isMobile',
    ];
    var ClickToPlayMethods = [
        'forceClick',
    ];
    var ClickToPlayOutputs = [];
    exports.ClickToPlay = /** @class */ (function () {
        function ClickToPlay(c, r, z) {
            this.z = z;
            define('vm-click-to-play', core.VmClickToPlay);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, []);
        }
        return ClickToPlay;
    }());
    exports.ClickToPlay.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-click-to-play',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: ClickToPlayInputs,
                    outputs: ClickToPlayOutputs
                },] }
    ];
    exports.ClickToPlay.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.ClickToPlay = __decorate([
        ProxyCmp({
            inputs: ClickToPlayInputs,
            methods: ClickToPlayMethods,
        })
    ], exports.ClickToPlay);

    var ControlInputs = [
        'keys',
        'identifier',
        'hidden',
        'label',
        'menu',
        'expanded',
        'pressed',
        'isTouch',
    ];
    var ControlMethods = [
        'focusControl',
        'blurControl',
    ];
    var ControlOutputs = [
        'vmInteractionChange',
        'vmFocus',
        'vmBlur',
    ];
    exports.Control = /** @class */ (function () {
        function Control(c, r, z) {
            this.z = z;
            define('vm-control', core.VmControl);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, ['vmInteractionChange', 'vmFocus', 'vmBlur']);
        }
        return Control;
    }());
    exports.Control.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-control',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: ControlInputs,
                    outputs: ControlOutputs
                },] }
    ];
    exports.Control.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.Control = __decorate([
        ProxyCmp({
            inputs: ControlInputs,
            methods: ControlMethods,
        })
    ], exports.Control);

    var ControlGroupInputs = [
        'space',
    ];
    var ControlGroupMethods = [];
    var ControlGroupOutputs = [];
    exports.ControlGroup = /** @class */ (function () {
        function ControlGroup(c, r, z) {
            this.z = z;
            define('vm-control-group', core.VmControlGroup);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, []);
        }
        return ControlGroup;
    }());
    exports.ControlGroup.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-control-group',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: ControlGroupInputs,
                    outputs: ControlGroupOutputs
                },] }
    ];
    exports.ControlGroup.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.ControlGroup = __decorate([
        ProxyCmp({
            inputs: ControlGroupInputs,
            methods: ControlGroupMethods,
        })
    ], exports.ControlGroup);

    var ControlSpacerInputs = [];
    var ControlSpacerMethods = [];
    var ControlSpacerOutputs = [];
    exports.ControlSpacer = /** @class */ (function () {
        function ControlSpacer(c, r, z) {
            this.z = z;
            define('vm-control-spacer', core.VmControlSpacer);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, []);
        }
        return ControlSpacer;
    }());
    exports.ControlSpacer.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-control-spacer',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: ControlSpacerInputs,
                    outputs: ControlSpacerOutputs
                },] }
    ];
    exports.ControlSpacer.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.ControlSpacer = __decorate([
        ProxyCmp({
            inputs: ControlSpacerInputs,
            methods: ControlSpacerMethods,
        })
    ], exports.ControlSpacer);

    var ControlsInputs = [
        'hidden',
        'fullWidth',
        'fullHeight',
        'direction',
        'align',
        'justify',
        'pin',
        'activeDuration',
        'waitForPlaybackStart',
        'hideWhenPaused',
        'hideOnMouseLeave',
        'isAudioView',
        'isSettingsActive',
        'playbackReady',
        'isControlsActive',
        'paused',
        'playbackStarted',
    ];
    var ControlsMethods = [];
    var ControlsOutputs = [];
    exports.Controls = /** @class */ (function () {
        function Controls(c, r, z) {
            this.z = z;
            define('vm-controls', core.VmControls);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, []);
        }
        return Controls;
    }());
    exports.Controls.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-controls',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: ControlsInputs,
                    outputs: ControlsOutputs
                },] }
    ];
    exports.Controls.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.Controls = __decorate([
        ProxyCmp({
            inputs: ControlsInputs,
            methods: ControlsMethods,
        })
    ], exports.Controls);

    var CurrentTimeInputs = [
        'currentTime',
        'i18n',
        'alwaysShowHours',
    ];
    var CurrentTimeMethods = [];
    var CurrentTimeOutputs = [];
    exports.CurrentTime = /** @class */ (function () {
        function CurrentTime(c, r, z) {
            this.z = z;
            define('vm-current-time', core.VmCurrentTime);
            define('vm-time', core.VmTime);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, []);
        }
        return CurrentTime;
    }());
    exports.CurrentTime.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-current-time',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: CurrentTimeInputs,
                    outputs: CurrentTimeOutputs
                },] }
    ];
    exports.CurrentTime.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.CurrentTime = __decorate([
        ProxyCmp({
            inputs: CurrentTimeInputs,
            methods: CurrentTimeMethods,
        })
    ], exports.CurrentTime);

    var DailymotionInputs = [
        'videoId',
        'shouldAutoplayQueue',
        'showUpNextQueue',
        'showShareButtons',
        'color',
        'syndication',
        'showDailymotionLogo',
        'showVideoInfo',
        'language',
        'autoplay',
        'controls',
        'poster',
        'logger',
        'loop',
        'muted',
        'playsinline',
    ];
    var DailymotionMethods = [
        'getAdapter',
    ];
    var DailymotionOutputs = [
        'vmError',
    ];
    exports.Dailymotion = /** @class */ (function () {
        function Dailymotion(c, r, z) {
            this.z = z;
            define('vm-dailymotion', core.VmDailymotion);
            define('vm-embed', core.VmEmbed);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, ['vmError']);
        }
        return Dailymotion;
    }());
    exports.Dailymotion.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-dailymotion',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: DailymotionInputs,
                    outputs: DailymotionOutputs
                },] }
    ];
    exports.Dailymotion.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.Dailymotion = __decorate([
        ProxyCmp({
            inputs: DailymotionInputs,
            methods: DailymotionMethods,
        })
    ], exports.Dailymotion);

    var DashInputs = [
        'src',
        'version',
        'libSrc',
        'config',
        'autoplay',
        'crossOrigin',
        'preload',
        'poster',
        'controlsList',
        'autoPiP',
        'disablePiP',
        'disableRemotePlayback',
        'mediaTitle',
        'enableTextTracksByDefault',
        'shouldRenderNativeTextTracks',
        'isTextTrackVisible',
        'currentTextTrack',
    ];
    var DashMethods = [
        'getAdapter',
    ];
    var DashOutputs = [
        'vmError',
    ];
    exports.Dash = /** @class */ (function () {
        function Dash(c, r, z) {
            this.z = z;
            define('vm-dash', core.VmDash);
            define('vm-file', core.VmFile);
            define('vm-video', core.VmVideo);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, ['vmError']);
        }
        return Dash;
    }());
    exports.Dash.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-dash',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: DashInputs,
                    outputs: DashOutputs
                },] }
    ];
    exports.Dash.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.Dash = __decorate([
        ProxyCmp({
            inputs: DashInputs,
            methods: DashMethods,
        })
    ], exports.Dash);

    var DblClickFullscreenInputs = [
        'useOnMobile',
        'isFullscreenActive',
        'isVideoView',
        'playbackReady',
        'isMobile',
    ];
    var DblClickFullscreenMethods = [];
    var DblClickFullscreenOutputs = [];
    exports.DblClickFullscreen = /** @class */ (function () {
        function DblClickFullscreen(c, r, z) {
            this.z = z;
            define('vm-dbl-click-fullscreen', core.VmDblClickFullscreen);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, []);
        }
        return DblClickFullscreen;
    }());
    exports.DblClickFullscreen.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-dbl-click-fullscreen',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: DblClickFullscreenInputs,
                    outputs: DblClickFullscreenOutputs
                },] }
    ];
    exports.DblClickFullscreen.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.DblClickFullscreen = __decorate([
        ProxyCmp({
            inputs: DblClickFullscreenInputs,
            methods: DblClickFullscreenMethods,
        })
    ], exports.DblClickFullscreen);

    var DefaultControlsInputs = [
        'activeDuration',
        'waitForPlaybackStart',
        'hideWhenPaused',
        'hideOnMouseLeave',
        'theme',
        'isMobile',
        'isLive',
        'isAudioView',
        'isVideoView',
    ];
    var DefaultControlsMethods = [];
    var DefaultControlsOutputs = [];
    exports.DefaultControls = /** @class */ (function () {
        function DefaultControls(c, r, z) {
            this.z = z;
            define('vm-default-controls', core.VmDefaultControls);
            define('vm-caption-control', core.VmCaptionControl);
            define('vm-control', core.VmControl);
            define('vm-icon', core.VmIcon);
            define('vm-tooltip', core.VmTooltip);
            define('vm-control-group', core.VmControlGroup);
            define('vm-control-spacer', core.VmControlSpacer);
            define('vm-controls', core.VmControls);
            define('vm-current-time', core.VmCurrentTime);
            define('vm-time', core.VmTime);
            define('vm-end-time', core.VmEndTime);
            define('vm-fullscreen-control', core.VmFullscreenControl);
            define('vm-live-indicator', core.VmLiveIndicator);
            define('vm-mute-control', core.VmMuteControl);
            define('vm-pip-control', core.VmPipControl);
            define('vm-playback-control', core.VmPlaybackControl);
            define('vm-scrim', core.VmScrim);
            define('vm-scrubber-control', core.VmScrubberControl);
            define('vm-slider', core.VmSlider);
            define('vm-settings-control', core.VmSettingsControl);
            define('vm-time-progress', core.VmTimeProgress);
            define('vm-volume-control', core.VmVolumeControl);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, []);
        }
        return DefaultControls;
    }());
    exports.DefaultControls.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-default-controls',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: DefaultControlsInputs,
                    outputs: DefaultControlsOutputs
                },] }
    ];
    exports.DefaultControls.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.DefaultControls = __decorate([
        ProxyCmp({
            inputs: DefaultControlsInputs,
            methods: DefaultControlsMethods,
        })
    ], exports.DefaultControls);

    var DefaultSettingsInputs = [
        'pin',
        'i18n',
        'playbackReady',
        'playbackRate',
        'playbackRates',
        'isVideoView',
        'playbackQuality',
        'playbackQualities',
        'textTracks',
        'currentTextTrack',
        'audioTracks',
        'currentAudioTrack',
        'isTextTrackVisible',
    ];
    var DefaultSettingsMethods = [];
    var DefaultSettingsOutputs = [];
    exports.DefaultSettings = /** @class */ (function () {
        function DefaultSettings(c, r, z) {
            this.z = z;
            define('vm-default-settings', core.VmDefaultSettings);
            define('vm-icon', core.VmIcon);
            define('vm-menu', core.VmMenu);
            define('vm-menu-item', core.VmMenuItem);
            define('vm-menu-radio', core.VmMenuRadio);
            define('vm-menu-radio-group', core.VmMenuRadioGroup);
            define('vm-settings', core.VmSettings);
            define('vm-submenu', core.VmSubmenu);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, []);
        }
        return DefaultSettings;
    }());
    exports.DefaultSettings.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-default-settings',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: DefaultSettingsInputs,
                    outputs: DefaultSettingsOutputs
                },] }
    ];
    exports.DefaultSettings.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.DefaultSettings = __decorate([
        ProxyCmp({
            inputs: DefaultSettingsInputs,
            methods: DefaultSettingsMethods,
        })
    ], exports.DefaultSettings);

    var DefaultUiInputs = [
        'noClickToPlay',
        'noDblClickFullscreen',
        'noCaptions',
        'noPoster',
        'noSpinner',
        'noControls',
        'noSettings',
        'noLoadingScreen',
    ];
    var DefaultUiMethods = [];
    var DefaultUiOutputs = [];
    exports.DefaultUi = /** @class */ (function () {
        function DefaultUi(c, r, z) {
            this.z = z;
            define('vm-default-ui', core.VmDefaultUi);
            define('vm-caption-control', core.VmCaptionControl);
            define('vm-control', core.VmControl);
            define('vm-icon', core.VmIcon);
            define('vm-tooltip', core.VmTooltip);
            define('vm-captions', core.VmCaptions);
            define('vm-click-to-play', core.VmClickToPlay);
            define('vm-control-group', core.VmControlGroup);
            define('vm-control-spacer', core.VmControlSpacer);
            define('vm-controls', core.VmControls);
            define('vm-current-time', core.VmCurrentTime);
            define('vm-time', core.VmTime);
            define('vm-dbl-click-fullscreen', core.VmDblClickFullscreen);
            define('vm-default-controls', core.VmDefaultControls);
            define('vm-end-time', core.VmEndTime);
            define('vm-fullscreen-control', core.VmFullscreenControl);
            define('vm-live-indicator', core.VmLiveIndicator);
            define('vm-mute-control', core.VmMuteControl);
            define('vm-pip-control', core.VmPipControl);
            define('vm-playback-control', core.VmPlaybackControl);
            define('vm-scrim', core.VmScrim);
            define('vm-scrubber-control', core.VmScrubberControl);
            define('vm-slider', core.VmSlider);
            define('vm-settings-control', core.VmSettingsControl);
            define('vm-time-progress', core.VmTimeProgress);
            define('vm-volume-control', core.VmVolumeControl);
            define('vm-default-settings', core.VmDefaultSettings);
            define('vm-menu', core.VmMenu);
            define('vm-menu-item', core.VmMenuItem);
            define('vm-menu-radio', core.VmMenuRadio);
            define('vm-menu-radio-group', core.VmMenuRadioGroup);
            define('vm-settings', core.VmSettings);
            define('vm-submenu', core.VmSubmenu);
            define('vm-loading-screen', core.VmLoadingScreen);
            define('vm-poster', core.VmPoster);
            define('vm-spinner', core.VmSpinner);
            define('vm-ui', core.VmUi);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, []);
        }
        return DefaultUi;
    }());
    exports.DefaultUi.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-default-ui',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: DefaultUiInputs,
                    outputs: DefaultUiOutputs
                },] }
    ];
    exports.DefaultUi.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.DefaultUi = __decorate([
        ProxyCmp({
            inputs: DefaultUiInputs,
            methods: DefaultUiMethods,
        })
    ], exports.DefaultUi);

    var EmbedInputs = [
        'embedSrc',
        'mediaTitle',
        'params',
        'origin',
        'preconnections',
        'decoder',
    ];
    var EmbedMethods = [
        'postMessage',
    ];
    var EmbedOutputs = [
        'vmEmbedSrcChange',
        'vmEmbedMessage',
        'vmEmbedLoaded',
    ];
    exports.Embed = /** @class */ (function () {
        function Embed(c, r, z) {
            this.z = z;
            define('vm-embed', core.VmEmbed);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, ['vmEmbedSrcChange', 'vmEmbedMessage', 'vmEmbedLoaded']);
        }
        return Embed;
    }());
    exports.Embed.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-embed',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: EmbedInputs,
                    outputs: EmbedOutputs
                },] }
    ];
    exports.Embed.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.Embed = __decorate([
        ProxyCmp({
            inputs: EmbedInputs,
            methods: EmbedMethods,
        })
    ], exports.Embed);

    var EndTimeInputs = [
        'duration',
        'i18n',
        'alwaysShowHours',
    ];
    var EndTimeMethods = [];
    var EndTimeOutputs = [];
    exports.EndTime = /** @class */ (function () {
        function EndTime(c, r, z) {
            this.z = z;
            define('vm-end-time', core.VmEndTime);
            define('vm-time', core.VmTime);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, []);
        }
        return EndTime;
    }());
    exports.EndTime.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-end-time',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: EndTimeInputs,
                    outputs: EndTimeOutputs
                },] }
    ];
    exports.EndTime.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.EndTime = __decorate([
        ProxyCmp({
            inputs: EndTimeInputs,
            methods: EndTimeMethods,
        })
    ], exports.EndTime);

    var FileInputs = [
        'willAttach',
        'crossOrigin',
        'preload',
        'poster',
        'mediaTitle',
        'controlsList',
        'autoPiP',
        'disablePiP',
        'disableRemotePlayback',
        'viewType',
        'playbackRates',
        'language',
        'autoplay',
        'controls',
        'logger',
        'loop',
        'muted',
        'playsinline',
        'noConnect',
        'paused',
        'currentTime',
        'volume',
        'playbackReady',
        'playbackStarted',
        'currentTextTrack',
        'hasCustomTextManager',
        'isTextTrackVisible',
        'shouldRenderNativeTextTracks',
    ];
    var FileMethods = [
        'getAdapter',
    ];
    var FileOutputs = [
        'vmError',
        'vmMediaElChange',
        'vmSrcSetChange',
    ];
    exports.File = /** @class */ (function () {
        function File(c, r, z) {
            this.z = z;
            define('vm-file', core.VmFile);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, ['vmError', 'vmMediaElChange', 'vmSrcSetChange']);
        }
        return File;
    }());
    exports.File.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-file',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: FileInputs,
                    outputs: FileOutputs
                },] }
    ];
    exports.File.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.File = __decorate([
        ProxyCmp({
            inputs: FileInputs,
            methods: FileMethods,
        })
    ], exports.File);

    var FullscreenControlInputs = [
        'enterIcon',
        'exitIcon',
        'icons',
        'tooltipPosition',
        'tooltipDirection',
        'hideTooltip',
        'keys',
        'isFullscreenActive',
        'i18n',
        'playbackReady',
    ];
    var FullscreenControlMethods = [];
    var FullscreenControlOutputs = [];
    exports.FullscreenControl = /** @class */ (function () {
        function FullscreenControl(c, r, z) {
            this.z = z;
            define('vm-fullscreen-control', core.VmFullscreenControl);
            define('vm-control', core.VmControl);
            define('vm-icon', core.VmIcon);
            define('vm-tooltip', core.VmTooltip);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, []);
        }
        return FullscreenControl;
    }());
    exports.FullscreenControl.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-fullscreen-control',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: FullscreenControlInputs,
                    outputs: FullscreenControlOutputs
                },] }
    ];
    exports.FullscreenControl.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.FullscreenControl = __decorate([
        ProxyCmp({
            inputs: FullscreenControlInputs,
            methods: FullscreenControlMethods,
        })
    ], exports.FullscreenControl);

    var HlsInputs = [
        'version',
        'libSrc',
        'config',
        'crossOrigin',
        'preload',
        'poster',
        'controlsList',
        'autoPiP',
        'disablePiP',
        'disableRemotePlayback',
        'playbackReady',
        'mediaTitle',
    ];
    var HlsMethods = [
        'getAdapter',
    ];
    var HlsOutputs = [
        'vmError',
    ];
    exports.Hls = /** @class */ (function () {
        function Hls(c, r, z) {
            this.z = z;
            define('vm-hls', core.VmHls);
            define('vm-file', core.VmFile);
            define('vm-video', core.VmVideo);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, ['vmError']);
        }
        return Hls;
    }());
    exports.Hls.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-hls',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: HlsInputs,
                    outputs: HlsOutputs
                },] }
    ];
    exports.Hls.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.Hls = __decorate([
        ProxyCmp({
            inputs: HlsInputs,
            methods: HlsMethods,
        })
    ], exports.Hls);

    var IconInputs = [
        'name',
        'src',
        'label',
        'library',
        'icons',
    ];
    var IconMethods = [
        'redraw',
    ];
    var IconOutputs = [
        'vmLoad',
        'vmError',
    ];
    exports.Icon = /** @class */ (function () {
        function Icon(c, r, z) {
            this.z = z;
            define('vm-icon', core.VmIcon);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, ['vmLoad', 'vmError']);
        }
        return Icon;
    }());
    exports.Icon.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-icon',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: IconInputs,
                    outputs: IconOutputs
                },] }
    ];
    exports.Icon.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.Icon = __decorate([
        ProxyCmp({
            inputs: IconInputs,
            methods: IconMethods,
        })
    ], exports.Icon);

    var IconLibraryInputs = [
        'name',
        'resolver',
        'icons',
    ];
    var IconLibraryMethods = [];
    var IconLibraryOutputs = [];
    exports.IconLibrary = /** @class */ (function () {
        function IconLibrary(c, r, z) {
            this.z = z;
            define('vm-icon-library', core.VmIconLibrary);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, []);
        }
        return IconLibrary;
    }());
    exports.IconLibrary.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-icon-library',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: IconLibraryInputs,
                    outputs: IconLibraryOutputs
                },] }
    ];
    exports.IconLibrary.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.IconLibrary = __decorate([
        ProxyCmp({
            inputs: IconLibraryInputs,
            methods: IconLibraryMethods,
        })
    ], exports.IconLibrary);

    var LiveIndicatorInputs = [
        'isLive',
        'i18n',
    ];
    var LiveIndicatorMethods = [];
    var LiveIndicatorOutputs = [];
    exports.LiveIndicator = /** @class */ (function () {
        function LiveIndicator(c, r, z) {
            this.z = z;
            define('vm-live-indicator', core.VmLiveIndicator);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, []);
        }
        return LiveIndicator;
    }());
    exports.LiveIndicator.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-live-indicator',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: LiveIndicatorInputs,
                    outputs: LiveIndicatorOutputs
                },] }
    ];
    exports.LiveIndicator.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.LiveIndicator = __decorate([
        ProxyCmp({
            inputs: LiveIndicatorInputs,
            methods: LiveIndicatorMethods,
        })
    ], exports.LiveIndicator);

    var LoadingScreenInputs = [
        'playbackReady',
        'hideDots',
    ];
    var LoadingScreenMethods = [];
    var LoadingScreenOutputs = [];
    exports.LoadingScreen = /** @class */ (function () {
        function LoadingScreen(c, r, z) {
            this.z = z;
            define('vm-loading-screen', core.VmLoadingScreen);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, []);
        }
        return LoadingScreen;
    }());
    exports.LoadingScreen.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-loading-screen',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: LoadingScreenInputs,
                    outputs: LoadingScreenOutputs
                },] }
    ];
    exports.LoadingScreen.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.LoadingScreen = __decorate([
        ProxyCmp({
            inputs: LoadingScreenInputs,
            methods: LoadingScreenMethods,
        })
    ], exports.LoadingScreen);

    var MenuInputs = [
        'active',
        'identifier',
        'controller',
        'slideInDirection',
    ];
    var MenuMethods = [
        'focusMenu',
        'blurMenu',
        'getActiveMenuItem',
        'setActiveMenuItem',
        'calculateHeight',
    ];
    var MenuOutputs = [
        'vmOpen',
        'vmClose',
        'vmFocus',
        'vmBlur',
        'vmActiveSubmenuChange',
        'vmActiveMenuItemChange',
        'vmMenuHeightChange',
    ];
    exports.Menu = /** @class */ (function () {
        function Menu(c, r, z) {
            this.z = z;
            define('vm-menu', core.VmMenu);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, ['vmOpen', 'vmClose', 'vmFocus', 'vmBlur', 'vmActiveSubmenuChange', 'vmActiveMenuItemChange', 'vmMenuHeightChange']);
        }
        return Menu;
    }());
    exports.Menu.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-menu',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: MenuInputs,
                    outputs: MenuOutputs
                },] }
    ];
    exports.Menu.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.Menu = __decorate([
        ProxyCmp({
            inputs: MenuInputs,
            methods: MenuMethods,
        })
    ], exports.Menu);

    var MenuItemInputs = [
        'identifier',
        'hidden',
        'label',
        'menu',
        'expanded',
        'checked',
        'hint',
        'badge',
        'checkIcon',
        'icons',
        'isTouch',
    ];
    var MenuItemMethods = [
        'focusItem',
        'blurItem',
        'getHeight',
    ];
    var MenuItemOutputs = [
        'vmFocus',
        'vmBlur',
    ];
    exports.MenuItem = /** @class */ (function () {
        function MenuItem(c, r, z) {
            this.z = z;
            define('vm-menu-item', core.VmMenuItem);
            define('vm-icon', core.VmIcon);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, ['vmFocus', 'vmBlur']);
        }
        return MenuItem;
    }());
    exports.MenuItem.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-menu-item',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: MenuItemInputs,
                    outputs: MenuItemOutputs
                },] }
    ];
    exports.MenuItem.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.MenuItem = __decorate([
        ProxyCmp({
            inputs: MenuItemInputs,
            methods: MenuItemMethods,
        })
    ], exports.MenuItem);

    var MenuRadioInputs = [
        'label',
        'value',
        'checked',
        'badge',
        'checkIcon',
        'icons',
    ];
    var MenuRadioMethods = [];
    var MenuRadioOutputs = [
        'vmCheck',
    ];
    exports.MenuRadio = /** @class */ (function () {
        function MenuRadio(c, r, z) {
            this.z = z;
            define('vm-menu-radio', core.VmMenuRadio);
            define('vm-icon', core.VmIcon);
            define('vm-menu-item', core.VmMenuItem);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, ['vmCheck']);
        }
        return MenuRadio;
    }());
    exports.MenuRadio.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-menu-radio',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: MenuRadioInputs,
                    outputs: MenuRadioOutputs
                },] }
    ];
    exports.MenuRadio.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.MenuRadio = __decorate([
        ProxyCmp({
            inputs: MenuRadioInputs,
            methods: MenuRadioMethods,
        })
    ], exports.MenuRadio);

    var MenuRadioGroupInputs = [
        'value',
    ];
    var MenuRadioGroupMethods = [];
    var MenuRadioGroupOutputs = [
        'vmCheck',
    ];
    exports.MenuRadioGroup = /** @class */ (function () {
        function MenuRadioGroup(c, r, z) {
            this.z = z;
            define('vm-menu-radio-group', core.VmMenuRadioGroup);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, ['vmCheck']);
        }
        return MenuRadioGroup;
    }());
    exports.MenuRadioGroup.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-menu-radio-group',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: MenuRadioGroupInputs,
                    outputs: MenuRadioGroupOutputs
                },] }
    ];
    exports.MenuRadioGroup.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.MenuRadioGroup = __decorate([
        ProxyCmp({
            inputs: MenuRadioGroupInputs,
            methods: MenuRadioGroupMethods,
        })
    ], exports.MenuRadioGroup);

    var MuteControlInputs = [
        'lowVolumeIcon',
        'highVolumeIcon',
        'mutedIcon',
        'icons',
        'tooltipPosition',
        'tooltipDirection',
        'hideTooltip',
        'keys',
        'volume',
        'muted',
        'i18n',
    ];
    var MuteControlMethods = [];
    var MuteControlOutputs = [
        'vmFocus',
        'vmBlur',
    ];
    exports.MuteControl = /** @class */ (function () {
        function MuteControl(c, r, z) {
            this.z = z;
            define('vm-mute-control', core.VmMuteControl);
            define('vm-control', core.VmControl);
            define('vm-icon', core.VmIcon);
            define('vm-tooltip', core.VmTooltip);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, ['vmFocus', 'vmBlur']);
        }
        return MuteControl;
    }());
    exports.MuteControl.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-mute-control',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: MuteControlInputs,
                    outputs: MuteControlOutputs
                },] }
    ];
    exports.MuteControl.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.MuteControl = __decorate([
        ProxyCmp({
            inputs: MuteControlInputs,
            methods: MuteControlMethods,
        })
    ], exports.MuteControl);

    var PipControlInputs = [
        'enterIcon',
        'exitIcon',
        'icons',
        'tooltipPosition',
        'tooltipDirection',
        'hideTooltip',
        'keys',
        'isPiPActive',
        'i18n',
        'playbackReady',
    ];
    var PipControlMethods = [];
    var PipControlOutputs = [];
    exports.PipControl = /** @class */ (function () {
        function PipControl(c, r, z) {
            this.z = z;
            define('vm-pip-control', core.VmPipControl);
            define('vm-control', core.VmControl);
            define('vm-icon', core.VmIcon);
            define('vm-tooltip', core.VmTooltip);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, []);
        }
        return PipControl;
    }());
    exports.PipControl.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-pip-control',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: PipControlInputs,
                    outputs: PipControlOutputs
                },] }
    ];
    exports.PipControl.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.PipControl = __decorate([
        ProxyCmp({
            inputs: PipControlInputs,
            methods: PipControlMethods,
        })
    ], exports.PipControl);

    var PlaybackControlInputs = [
        'playIcon',
        'pauseIcon',
        'icons',
        'tooltipPosition',
        'tooltipDirection',
        'hideTooltip',
        'keys',
        'paused',
        'i18n',
    ];
    var PlaybackControlMethods = [];
    var PlaybackControlOutputs = [];
    exports.PlaybackControl = /** @class */ (function () {
        function PlaybackControl(c, r, z) {
            this.z = z;
            define('vm-playback-control', core.VmPlaybackControl);
            define('vm-control', core.VmControl);
            define('vm-icon', core.VmIcon);
            define('vm-tooltip', core.VmTooltip);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, []);
        }
        return PlaybackControl;
    }());
    exports.PlaybackControl.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-playback-control',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: PlaybackControlInputs,
                    outputs: PlaybackControlOutputs
                },] }
    ];
    exports.PlaybackControl.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.PlaybackControl = __decorate([
        ProxyCmp({
            inputs: PlaybackControlInputs,
            methods: PlaybackControlMethods,
        })
    ], exports.PlaybackControl);

    var PlayerInputs = [
        'logger',
        'theme',
        'icons',
        'paused',
        'playing',
        'duration',
        'mediaTitle',
        'currentProvider',
        'currentSrc',
        'currentPoster',
        'currentTime',
        'autoplay',
        'ready',
        'playbackReady',
        'loop',
        'muted',
        'buffered',
        'playbackRate',
        'playbackRates',
        'playbackQuality',
        'playbackQualities',
        'seeking',
        'debug',
        'playbackStarted',
        'playbackEnded',
        'buffering',
        'controls',
        'isControlsActive',
        'isSettingsActive',
        'volume',
        'isFullscreenActive',
        'aspectRatio',
        'viewType',
        'isAudioView',
        'isVideoView',
        'mediaType',
        'isAudio',
        'isVideo',
        'isLive',
        'isMobile',
        'isTouch',
        'isPiPActive',
        'textTracks',
        'currentTextTrack',
        'isTextTrackVisible',
        'shouldRenderNativeTextTracks',
        'audioTracks',
        'currentAudioTrack',
        'autopause',
        'playsinline',
        'language',
        'translations',
        'languages',
        'i18n',
    ];
    var PlayerMethods = [
        'getProvider',
        'getAdapter',
        'play',
        'pause',
        'canPlay',
        'canAutoplay',
        'canMutedAutoplay',
        'canSetPlaybackRate',
        'canSetPlaybackQuality',
        'canSetFullscreen',
        'enterFullscreen',
        'exitFullscreen',
        'canSetPiP',
        'enterPiP',
        'exitPiP',
        'canSetAudioTrack',
        'setCurrentAudioTrack',
        'canSetTextTrack',
        'setCurrentTextTrack',
        'canSetTextTrackVisibility',
        'setTextTrackVisibility',
        'extendLanguage',
        'getContainer',
        'callAdapter',
    ];
    var PlayerOutputs = [
        'vmThemeChange',
        'vmPausedChange',
        'vmPlay',
        'vmPlayingChange',
        'vmSeekingChange',
        'vmSeeked',
        'vmBufferingChange',
        'vmDurationChange',
        'vmCurrentTimeChange',
        'vmReady',
        'vmPlaybackReady',
        'vmPlaybackStarted',
        'vmPlaybackEnded',
        'vmBufferedChange',
        'vmError',
        'vmLoadStart',
        'vmCurrentProviderChange',
        'vmCurrentSrcChange',
        'vmCurrentPosterChange',
        'vmMediaTitleChange',
        'vmControlsChange',
        'vmPlaybackRateChange',
        'vmPlaybackRatesChange',
        'vmPlaybackQualityChange',
        'vmPlaybackQualitiesChange',
        'vmMutedChange',
        'vmVolumeChange',
        'vmViewTypeChange',
        'vmMediaTypeChange',
        'vmLiveChange',
        'vmTouchChange',
        'vmLanguageChange',
        'vmI18nChange',
        'vmTranslationsChange',
        'vmLanguagesChange',
        'vmFullscreenChange',
        'vmPiPChange',
        'vmTextTracksChange',
        'vmCurrentTextTrackChange',
        'vmTextTrackVisibleChange',
        'vmAudioTracksChange',
        'vmCurrentAudioTrackChange',
    ];
    exports.Player = /** @class */ (function () {
        function Player(c, r, z) {
            this.z = z;
            define('vm-player', core.VmPlayer);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, ['vmThemeChange', 'vmPausedChange', 'vmPlay', 'vmPlayingChange', 'vmSeekingChange', 'vmSeeked', 'vmBufferingChange', 'vmDurationChange', 'vmCurrentTimeChange', 'vmReady', 'vmPlaybackReady', 'vmPlaybackStarted', 'vmPlaybackEnded', 'vmBufferedChange', 'vmError', 'vmLoadStart', 'vmCurrentProviderChange', 'vmCurrentSrcChange', 'vmCurrentPosterChange', 'vmMediaTitleChange', 'vmControlsChange', 'vmPlaybackRateChange', 'vmPlaybackRatesChange', 'vmPlaybackQualityChange', 'vmPlaybackQualitiesChange', 'vmMutedChange', 'vmVolumeChange', 'vmViewTypeChange', 'vmMediaTypeChange', 'vmLiveChange', 'vmTouchChange', 'vmLanguageChange', 'vmI18nChange', 'vmTranslationsChange', 'vmLanguagesChange', 'vmFullscreenChange', 'vmPiPChange', 'vmTextTracksChange', 'vmCurrentTextTrackChange', 'vmTextTrackVisibleChange', 'vmAudioTracksChange', 'vmCurrentAudioTrackChange']);
        }
        return Player;
    }());
    exports.Player.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-player',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: PlayerInputs,
                    outputs: PlayerOutputs
                },] }
    ];
    exports.Player.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.Player = __decorate([
        ProxyCmp({
            inputs: PlayerInputs,
            methods: PlayerMethods,
        })
    ], exports.Player);

    var PosterInputs = [
        'fit',
        'isVideoView',
        'currentPoster',
        'mediaTitle',
        'playbackStarted',
        'currentTime',
    ];
    var PosterMethods = [];
    var PosterOutputs = [
        'vmLoaded',
        'vmWillShow',
        'vmWillHide',
    ];
    exports.Poster = /** @class */ (function () {
        function Poster(c, r, z) {
            this.z = z;
            define('vm-poster', core.VmPoster);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, ['vmLoaded', 'vmWillShow', 'vmWillHide']);
        }
        return Poster;
    }());
    exports.Poster.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-poster',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: PosterInputs,
                    outputs: PosterOutputs
                },] }
    ];
    exports.Poster.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.Poster = __decorate([
        ProxyCmp({
            inputs: PosterInputs,
            methods: PosterMethods,
        })
    ], exports.Poster);

    var ScrimInputs = [
        'gradient',
        'isVideoView',
        'isControlsActive',
    ];
    var ScrimMethods = [];
    var ScrimOutputs = [];
    exports.Scrim = /** @class */ (function () {
        function Scrim(c, r, z) {
            this.z = z;
            define('vm-scrim', core.VmScrim);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, []);
        }
        return Scrim;
    }());
    exports.Scrim.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-scrim',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: ScrimInputs,
                    outputs: ScrimOutputs
                },] }
    ];
    exports.Scrim.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.Scrim = __decorate([
        ProxyCmp({
            inputs: ScrimInputs,
            methods: ScrimMethods,
        })
    ], exports.Scrim);

    var ScrubberControlInputs = [
        'alwaysShowHours',
        'hideTooltip',
        'currentTime',
        'duration',
        'noKeyboard',
        'buffering',
        'buffered',
        'i18n',
    ];
    var ScrubberControlMethods = [];
    var ScrubberControlOutputs = [];
    exports.ScrubberControl = /** @class */ (function () {
        function ScrubberControl(c, r, z) {
            this.z = z;
            define('vm-scrubber-control', core.VmScrubberControl);
            define('vm-slider', core.VmSlider);
            define('vm-tooltip', core.VmTooltip);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, []);
        }
        return ScrubberControl;
    }());
    exports.ScrubberControl.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-scrubber-control',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: ScrubberControlInputs,
                    outputs: ScrubberControlOutputs
                },] }
    ];
    exports.ScrubberControl.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.ScrubberControl = __decorate([
        ProxyCmp({
            inputs: ScrubberControlInputs,
            methods: ScrubberControlMethods,
        })
    ], exports.ScrubberControl);

    var SettingsInputs = [
        'pin',
        'active',
        'isMobile',
        'isAudioView',
    ];
    var SettingsMethods = [
        'setController',
    ];
    var SettingsOutputs = [];
    exports.Settings = /** @class */ (function () {
        function Settings(c, r, z) {
            this.z = z;
            define('vm-settings', core.VmSettings);
            define('vm-menu', core.VmMenu);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, []);
        }
        return Settings;
    }());
    exports.Settings.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-settings',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: SettingsInputs,
                    outputs: SettingsOutputs
                },] }
    ];
    exports.Settings.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.Settings = __decorate([
        ProxyCmp({
            inputs: SettingsInputs,
            methods: SettingsMethods,
        })
    ], exports.Settings);

    var SettingsControlInputs = [
        'icon',
        'icons',
        'tooltipPosition',
        'tooltipDirection',
        'menu',
        'expanded',
        'i18n',
        'hideTooltip',
    ];
    var SettingsControlMethods = [
        'focusControl',
        'blurControl',
    ];
    var SettingsControlOutputs = [];
    exports.SettingsControl = /** @class */ (function () {
        function SettingsControl(c, r, z) {
            this.z = z;
            define('vm-settings-control', core.VmSettingsControl);
            define('vm-control', core.VmControl);
            define('vm-icon', core.VmIcon);
            define('vm-tooltip', core.VmTooltip);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, []);
        }
        return SettingsControl;
    }());
    exports.SettingsControl.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-settings-control',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: SettingsControlInputs,
                    outputs: SettingsControlOutputs
                },] }
    ];
    exports.SettingsControl.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.SettingsControl = __decorate([
        ProxyCmp({
            inputs: SettingsControlInputs,
            methods: SettingsControlMethods,
        })
    ], exports.SettingsControl);

    var SkeletonInputs = [
        'effect',
        'ready',
    ];
    var SkeletonMethods = [];
    var SkeletonOutputs = [];
    exports.Skeleton = /** @class */ (function () {
        function Skeleton(c, r, z) {
            this.z = z;
            define('vm-skeleton', core.VmSkeleton);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, []);
        }
        return Skeleton;
    }());
    exports.Skeleton.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-skeleton',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: SkeletonInputs,
                    outputs: SkeletonOutputs
                },] }
    ];
    exports.Skeleton.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.Skeleton = __decorate([
        ProxyCmp({
            inputs: SkeletonInputs,
            methods: SkeletonMethods,
        })
    ], exports.Skeleton);

    var SliderInputs = [
        'step',
        'min',
        'max',
        'value',
        'valueText',
        'label',
    ];
    var SliderMethods = [];
    var SliderOutputs = [
        'vmValueChange',
        'vmFocus',
        'vmBlur',
    ];
    exports.Slider = /** @class */ (function () {
        function Slider(c, r, z) {
            this.z = z;
            define('vm-slider', core.VmSlider);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, ['vmValueChange', 'vmFocus', 'vmBlur']);
        }
        return Slider;
    }());
    exports.Slider.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-slider',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: SliderInputs,
                    outputs: SliderOutputs
                },] }
    ];
    exports.Slider.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.Slider = __decorate([
        ProxyCmp({
            inputs: SliderInputs,
            methods: SliderMethods,
        })
    ], exports.Slider);

    var SpinnerInputs = [
        'isVideoView',
        'currentProvider',
        'showWhenMediaLoading',
        'playbackReady',
        'buffering',
    ];
    var SpinnerMethods = [];
    var SpinnerOutputs = [
        'vmWillShow',
        'vmWillHide',
    ];
    exports.Spinner = /** @class */ (function () {
        function Spinner(c, r, z) {
            this.z = z;
            define('vm-spinner', core.VmSpinner);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, ['vmWillShow', 'vmWillHide']);
        }
        return Spinner;
    }());
    exports.Spinner.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-spinner',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: SpinnerInputs,
                    outputs: SpinnerOutputs
                },] }
    ];
    exports.Spinner.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.Spinner = __decorate([
        ProxyCmp({
            inputs: SpinnerInputs,
            methods: SpinnerMethods,
        })
    ], exports.Spinner);

    var SubmenuInputs = [
        'label',
        'hint',
        'slideInDirection',
        'active',
    ];
    var SubmenuMethods = [
        'getController',
        'getMenu',
        'getControllerHeight',
    ];
    var SubmenuOutputs = [
        'vmOpenSubmenu',
        'vmCloseSubmenu',
    ];
    exports.Submenu = /** @class */ (function () {
        function Submenu(c, r, z) {
            this.z = z;
            define('vm-submenu', core.VmSubmenu);
            define('vm-icon', core.VmIcon);
            define('vm-menu', core.VmMenu);
            define('vm-menu-item', core.VmMenuItem);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, ['vmOpenSubmenu', 'vmCloseSubmenu']);
        }
        return Submenu;
    }());
    exports.Submenu.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-submenu',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: SubmenuInputs,
                    outputs: SubmenuOutputs
                },] }
    ];
    exports.Submenu.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.Submenu = __decorate([
        ProxyCmp({
            inputs: SubmenuInputs,
            methods: SubmenuMethods,
        })
    ], exports.Submenu);

    var TimeInputs = [
        'label',
        'seconds',
        'alwaysShowHours',
    ];
    var TimeMethods = [];
    var TimeOutputs = [];
    exports.Time = /** @class */ (function () {
        function Time(c, r, z) {
            this.z = z;
            define('vm-time', core.VmTime);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, []);
        }
        return Time;
    }());
    exports.Time.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-time',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: TimeInputs,
                    outputs: TimeOutputs
                },] }
    ];
    exports.Time.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.Time = __decorate([
        ProxyCmp({
            inputs: TimeInputs,
            methods: TimeMethods,
        })
    ], exports.Time);

    var TimeProgressInputs = [
        'separator',
        'alwaysShowHours',
    ];
    var TimeProgressMethods = [];
    var TimeProgressOutputs = [];
    exports.TimeProgress = /** @class */ (function () {
        function TimeProgress(c, r, z) {
            this.z = z;
            define('vm-time-progress', core.VmTimeProgress);
            define('vm-current-time', core.VmCurrentTime);
            define('vm-time', core.VmTime);
            define('vm-end-time', core.VmEndTime);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, []);
        }
        return TimeProgress;
    }());
    exports.TimeProgress.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-time-progress',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: TimeProgressInputs,
                    outputs: TimeProgressOutputs
                },] }
    ];
    exports.TimeProgress.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.TimeProgress = __decorate([
        ProxyCmp({
            inputs: TimeProgressInputs,
            methods: TimeProgressMethods,
        })
    ], exports.TimeProgress);

    var TooltipInputs = [
        'hidden',
        'active',
        'position',
        'direction',
        'isTouch',
        'isMobile',
    ];
    var TooltipMethods = [];
    var TooltipOutputs = [];
    exports.Tooltip = /** @class */ (function () {
        function Tooltip(c, r, z) {
            this.z = z;
            define('vm-tooltip', core.VmTooltip);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, []);
        }
        return Tooltip;
    }());
    exports.Tooltip.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-tooltip',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: TooltipInputs,
                    outputs: TooltipOutputs
                },] }
    ];
    exports.Tooltip.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.Tooltip = __decorate([
        ProxyCmp({
            inputs: TooltipInputs,
            methods: TooltipMethods,
        })
    ], exports.Tooltip);

    var UiInputs = [
        'isVideoView',
        'playsinline',
        'isFullscreenActive',
    ];
    var UiMethods = [];
    var UiOutputs = [];
    exports.Ui = /** @class */ (function () {
        function Ui(c, r, z) {
            this.z = z;
            define('vm-ui', core.VmUi);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, []);
        }
        return Ui;
    }());
    exports.Ui.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-ui',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: UiInputs,
                    outputs: UiOutputs
                },] }
    ];
    exports.Ui.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.Ui = __decorate([
        ProxyCmp({
            inputs: UiInputs,
            methods: UiMethods,
        })
    ], exports.Ui);

    var VideoInputs = [
        'willAttach',
        'hasCustomTextManager',
        'crossOrigin',
        'preload',
        'poster',
        'controlsList',
        'autoPiP',
        'disablePiP',
        'disableRemotePlayback',
        'mediaTitle',
    ];
    var VideoMethods = [
        'getAdapter',
    ];
    var VideoOutputs = [];
    exports.Video = /** @class */ (function () {
        function Video(c, r, z) {
            this.z = z;
            define('vm-video', core.VmVideo);
            define('vm-file', core.VmFile);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, []);
        }
        return Video;
    }());
    exports.Video.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-video',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: VideoInputs,
                    outputs: VideoOutputs
                },] }
    ];
    exports.Video.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.Video = __decorate([
        ProxyCmp({
            inputs: VideoInputs,
            methods: VideoMethods,
        })
    ], exports.Video);

    var VimeoInputs = [
        'videoId',
        'byline',
        'color',
        'portrait',
        'noAutoAspectRatio',
        'poster',
        'cookies',
        'language',
        'aspectRatio',
        'autoplay',
        'controls',
        'logger',
        'loop',
        'muted',
        'playsinline',
    ];
    var VimeoMethods = [
        'getAdapter',
    ];
    var VimeoOutputs = [
        'vmError',
    ];
    exports.Vimeo = /** @class */ (function () {
        function Vimeo(c, r, z) {
            this.z = z;
            define('vm-vimeo', core.VmVimeo);
            define('vm-embed', core.VmEmbed);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, ['vmError']);
        }
        return Vimeo;
    }());
    exports.Vimeo.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-vimeo',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: VimeoInputs,
                    outputs: VimeoOutputs
                },] }
    ];
    exports.Vimeo.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.Vimeo = __decorate([
        ProxyCmp({
            inputs: VimeoInputs,
            methods: VimeoMethods,
        })
    ], exports.Vimeo);

    var VolumeControlInputs = [
        'lowVolumeIcon',
        'highVolumeIcon',
        'mutedIcon',
        'icons',
        'tooltipPosition',
        'tooltipDirection',
        'hideTooltip',
        'muteKeys',
        'noKeyboard',
        'muted',
        'volume',
        'isMobile',
        'i18n',
    ];
    var VolumeControlMethods = [];
    var VolumeControlOutputs = [];
    exports.VolumeControl = /** @class */ (function () {
        function VolumeControl(c, r, z) {
            this.z = z;
            define('vm-volume-control', core.VmVolumeControl);
            define('vm-control', core.VmControl);
            define('vm-icon', core.VmIcon);
            define('vm-mute-control', core.VmMuteControl);
            define('vm-tooltip', core.VmTooltip);
            define('vm-slider', core.VmSlider);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, []);
        }
        return VolumeControl;
    }());
    exports.VolumeControl.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-volume-control',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: VolumeControlInputs,
                    outputs: VolumeControlOutputs
                },] }
    ];
    exports.VolumeControl.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.VolumeControl = __decorate([
        ProxyCmp({
            inputs: VolumeControlInputs,
            methods: VolumeControlMethods,
        })
    ], exports.VolumeControl);

    var YoutubeInputs = [
        'cookies',
        'videoId',
        'showFullscreenControl',
        'poster',
        'language',
        'autoplay',
        'controls',
        'logger',
        'loop',
        'muted',
        'playsinline',
    ];
    var YoutubeMethods = [
        'getAdapter',
    ];
    var YoutubeOutputs = [];
    exports.Youtube = /** @class */ (function () {
        function Youtube(c, r, z) {
            this.z = z;
            define('vm-youtube', core.VmYoutube);
            define('vm-embed', core.VmEmbed);
            c.detach();
            this.el = r.nativeElement;
            initOutputs(this, []);
        }
        return Youtube;
    }());
    exports.Youtube.decorators = [
        { type: core$1.Component, args: [{
                    selector: 'vm-youtube',
                    changeDetection: core$1.ChangeDetectionStrategy.OnPush,
                    template: '<ng-content></ng-content>',
                    inputs: YoutubeInputs,
                    outputs: YoutubeOutputs
                },] }
    ];
    exports.Youtube.ctorParameters = function () { return [
        { type: core$1.ChangeDetectorRef },
        { type: core$1.ElementRef },
        { type: core$1.NgZone }
    ]; };
    exports.Youtube = __decorate([
        ProxyCmp({
            inputs: YoutubeInputs,
            methods: YoutubeMethods,
        })
    ], exports.Youtube);

    /* eslint-disable */

    var VimeComponent = /** @class */ (function () {
        function VimeComponent(playerProps) {
            var _this = this;
            this.playerProps = playerProps;
            this.playerDispatch = function () { };
            this.unbindPlayerContext = function () { };
            this.playerCache = new Map();
            playerProps.forEach(function (prop) {
                _this.playerCache.set(prop, _this[prop]);
            });
            var props = playerProps.reduce(function (prev, prop) {
                var _b;
                return (Object.assign(Object.assign({}, prev), (_b = {}, _b[prop] = {
                    get: function () {
                        return this.playerCache.get(prop);
                    },
                    set: function (value) {
                        if (_this.playerCache.get(prop) !== value) {
                            _this.playerDispatch(prop, value);
                            _this.playerCache.set(prop, value);
                        }
                    },
                }, _b)));
            }, {});
            Object.defineProperties(this, props);
        }
        VimeComponent.prototype.ngAfterViewInit = function () {
            return __awaiter(this, void 0, void 0, function () {
                var _b, _c;
                var _this = this;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            if (!this.ref.nativeElement)
                                return [2 /*return*/];
                            _b = this;
                            return [4 /*yield*/, core.findPlayer(this.ref.nativeElement)];
                        case 1:
                            _b.player = _d.sent();
                            if (!this.player)
                                return [2 /*return*/];
                            this.playerDispatch = core.createDispatcher(this.ref.nativeElement);
                            _c = this;
                            return [4 /*yield*/, core.usePlayerContext(this.ref.nativeElement, this.playerProps, function (prop, value) {
                                    _this.playerCache.set(prop, value);
                                    _this[prop] = value;
                                }, this.player)];
                        case 2:
                            _c.unbindPlayerContext = _d.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        VimeComponent.prototype.ngOnDestroy = function () {
            var _a;
            (_a = this.unbindPlayerContext) === null || _a === void 0 ? void 0 : _a.call(this);
            this.playerCache.clear();
        };
        return VimeComponent;
    }());
    VimeComponent.decorators = [
        { type: core$1.Injectable }
    ];
    VimeComponent.ctorParameters = function () { return [
        { type: Array }
    ]; };

    /* eslint-disable */
    var DECLARATIONS = [
        exports.Audio,
        exports.CaptionControl,
        exports.Captions,
        exports.ClickToPlay,
        exports.Control,
        exports.ControlGroup,
        exports.ControlSpacer,
        exports.Controls,
        exports.CurrentTime,
        exports.Dailymotion,
        exports.Dash,
        exports.DblClickFullscreen,
        exports.DefaultControls,
        exports.DefaultSettings,
        exports.DefaultUi,
        exports.Embed,
        exports.EndTime,
        exports.File,
        exports.FullscreenControl,
        exports.Hls,
        exports.Icon,
        exports.IconLibrary,
        exports.LiveIndicator,
        exports.LoadingScreen,
        exports.Menu,
        exports.MenuItem,
        exports.MenuRadio,
        exports.MenuRadioGroup,
        exports.MuteControl,
        exports.PipControl,
        exports.PlaybackControl,
        exports.Player,
        exports.Poster,
        exports.Scrim,
        exports.ScrubberControl,
        exports.Settings,
        exports.SettingsControl,
        exports.Skeleton,
        exports.Slider,
        exports.Spinner,
        exports.Submenu,
        exports.Time,
        exports.TimeProgress,
        exports.Tooltip,
        exports.Ui,
        exports.Video,
        exports.Vimeo,
        exports.VolumeControl,
        exports.Youtube,
    ];
    var VimeModule = /** @class */ (function () {
        function VimeModule() {
        }
        return VimeModule;
    }());
    VimeModule.decorators = [
        { type: core$1.NgModule, args: [{
                    declarations: DECLARATIONS,
                    exports: DECLARATIONS,
                    imports: [],
                    providers: [],
                },] }
    ];

    /**
     * Generated bundle index. Do not edit.
     */

    Object.defineProperty(exports, 'MediaType', {
        enumerable: true,
        get: function () { return core.MediaType; }
    });
    Object.defineProperty(exports, 'Provider', {
        enumerable: true,
        get: function () { return core.Provider; }
    });
    Object.defineProperty(exports, 'ViewType', {
        enumerable: true,
        get: function () { return core.ViewType; }
    });
    Object.defineProperty(exports, 'watchComponentRegistry', {
        enumerable: true,
        get: function () { return core.watchComponentRegistry; }
    });
    exports.VimeComponent = VimeComponent;
    exports.VimeModule = VimeModule;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=vime-angular.umd.js.map
