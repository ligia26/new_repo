import { __decorate } from "tslib";
/* eslint-disable */
/* tslint:disable */
// @ts-nocheck
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, NgZone } from '@angular/core';
import { ProxyCmp, initOutputs } from '../lib';
import { VmMuteControl, VmControl, VmIcon, VmTooltip } from '@vime/core';
import { define } from '../lib';
const MuteControlInputs = [
    'lowVolumeIcon',
    'highVolumeIcon',
    'mutedIcon',
    'icons',
    'tooltipPosition',
    'tooltipDirection',
    'hideTooltip',
    'keys',
    'volume',
    'muted',
    'i18n',
];
const MuteControlMethods = [];
const MuteControlOutputs = [
    'vmFocus',
    'vmBlur',
];
let MuteControl = class MuteControl {
    constructor(c, r, z) {
        this.z = z;
        define('vm-mute-control', VmMuteControl);
        define('vm-control', VmControl);
        define('vm-icon', VmIcon);
        define('vm-tooltip', VmTooltip);
        c.detach();
        this.el = r.nativeElement;
        initOutputs(this, ['vmFocus', 'vmBlur']);
    }
};
MuteControl.decorators = [
    { type: Component, args: [{
                selector: 'vm-mute-control',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: '<ng-content></ng-content>',
                inputs: MuteControlInputs,
                outputs: MuteControlOutputs
            },] }
];
MuteControl.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
MuteControl = __decorate([
    ProxyCmp({
        inputs: MuteControlInputs,
        methods: MuteControlMethods,
    })
], MuteControl);
export { MuteControl };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTXV0ZUNvbnRyb2wuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9wcm9qZWN0cy92aW1lL3NyYy9jb21wb25lbnRzL011dGVDb250cm9sLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQSxvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLGNBQWM7QUFDZCxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsaUJBQWlCLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBZ0IsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3hILE9BQU8sRUFBRSxRQUFRLEVBQUUsV0FBVyxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBRy9DLE9BQU8sRUFDTCxhQUFhLEVBQ2IsU0FBUyxFQUNULE1BQU0sRUFDTixTQUFTLEVBQ1YsTUFBTSxZQUFZLENBQUM7QUFFcEIsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLFFBQVEsQ0FBQztBQUdoQyxNQUFNLGlCQUFpQixHQUFhO0lBQ2xDLGVBQWU7SUFDZixnQkFBZ0I7SUFDaEIsV0FBVztJQUNYLE9BQU87SUFDUCxpQkFBaUI7SUFDakIsa0JBQWtCO0lBQ2xCLGFBQWE7SUFDYixNQUFNO0lBQ04sUUFBUTtJQUNSLE9BQU87SUFDUCxNQUFNO0NBQ1AsQ0FBQztBQUVGLE1BQU0sa0JBQWtCLEdBQWEsRUFFcEMsQ0FBQztBQUVGLE1BQU0sa0JBQWtCLEdBQWE7SUFDbkMsU0FBUztJQUNULFFBQVE7Q0FDVCxDQUFDO0lBaUJXLFdBQVcsU0FBWCxXQUFXO0lBUXRCLFlBQVksQ0FBb0IsRUFBRSxDQUFhLEVBQVksQ0FBUztRQUFULE1BQUMsR0FBRCxDQUFDLENBQVE7UUFDbEUsTUFBTSxDQUFDLGlCQUFpQixFQUFFLGFBQWEsQ0FBQyxDQUFDO1FBQ3pDLE1BQU0sQ0FBQyxZQUFZLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFDaEMsTUFBTSxDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUMxQixNQUFNLENBQUMsWUFBWSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBQ2hDLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUNYLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLGFBQWEsQ0FBQztRQUMxQixXQUFXLENBQUMsSUFBSSxFQUFFLENBQUMsU0FBUyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUE7SUFDMUMsQ0FBQztDQUNGLENBQUE7O1lBeEJBLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUsaUJBQWlCO2dCQUMzQixlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtnQkFDL0MsUUFBUSxFQUFFLDJCQUEyQjtnQkFDckMsTUFBTSxFQUFFLGlCQUFpQjtnQkFDekIsT0FBTyxFQUFFLGtCQUFrQjthQUM1Qjs7O1lBbkRpQyxpQkFBaUI7WUFBYSxVQUFVO1lBQWdCLE1BQU07O0FBb0RuRixXQUFXO0lBWHZCLFFBQVEsQ0FBQztRQUNSLE1BQU0sRUFBRSxpQkFBaUI7UUFDekIsT0FBTyxFQUFFLGtCQUFrQjtLQUM1QixDQUFDO0dBUVcsV0FBVyxDQWlCdkI7U0FqQlksV0FBVyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qIHRzbGludDpkaXNhYmxlICovXG4vLyBAdHMtbm9jaGVja1xuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENoYW5nZURldGVjdG9yUmVmLCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBQcm94eUNtcCwgaW5pdE91dHB1dHMgfSBmcm9tICcuLi9saWInO1xuaW1wb3J0IHR5cGUgeyBKU1gsIENvbXBvbmVudHMgfSBmcm9tICdAdmltZS9jb3JlL2Rpc3QvdHlwZXMnO1xuXG5pbXBvcnQgeyBcbiAgVm1NdXRlQ29udHJvbCxcbiAgVm1Db250cm9sLFxuICBWbUljb24sXG4gIFZtVG9vbHRpcCBcbn0gZnJvbSAnQHZpbWUvY29yZSc7XG5cbmltcG9ydCB7IGRlZmluZSB9IGZyb20gJy4uL2xpYic7XG4gIFxuXG5jb25zdCBNdXRlQ29udHJvbElucHV0czogc3RyaW5nW10gPSBbXG4gICdsb3dWb2x1bWVJY29uJyxcbiAgJ2hpZ2hWb2x1bWVJY29uJyxcbiAgJ211dGVkSWNvbicsXG4gICdpY29ucycsXG4gICd0b29sdGlwUG9zaXRpb24nLFxuICAndG9vbHRpcERpcmVjdGlvbicsXG4gICdoaWRlVG9vbHRpcCcsXG4gICdrZXlzJyxcbiAgJ3ZvbHVtZScsXG4gICdtdXRlZCcsXG4gICdpMThuJyxcbl07XG5cbmNvbnN0IE11dGVDb250cm9sTWV0aG9kczogc3RyaW5nW10gPSBbXG4gIFxuXTtcblxuY29uc3QgTXV0ZUNvbnRyb2xPdXRwdXRzOiBzdHJpbmdbXSA9IFtcbiAgJ3ZtRm9jdXMnLFxuICAndm1CbHVyJyxcbl07XG5cbmV4cG9ydCB0eXBlIEVtaXR0ZXI8VCBleHRlbmRzICgoLi4uYXJnczogYW55W10pID0+IGFueSkgfCB1bmRlZmluZWQ+ID0gRXZlbnRFbWl0dGVyPFBhcmFtZXRlcnM8RXhjbHVkZTxULCB1bmRlZmluZWQ+PlswXT47XG5cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBNdXRlQ29udHJvbCBleHRlbmRzIENvbXBvbmVudHMuVm1NdXRlQ29udHJvbCB7fVxuXG5AUHJveHlDbXAoe1xuICBpbnB1dHM6IE11dGVDb250cm9sSW5wdXRzLFxuICBtZXRob2RzOiBNdXRlQ29udHJvbE1ldGhvZHMsXG59KVxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndm0tbXV0ZS1jb250cm9sJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXG4gIGlucHV0czogTXV0ZUNvbnRyb2xJbnB1dHMsXG4gIG91dHB1dHM6IE11dGVDb250cm9sT3V0cHV0cyxcbn0pXG5leHBvcnQgY2xhc3MgTXV0ZUNvbnRyb2wge1xuICBwcm90ZWN0ZWQgZWw6IEhUTUxFbGVtZW50O1xuXG4gIC8qKiBFbWl0dGVkIHdoZW4gdGhlIGNvbnRyb2wgcmVjZWl2ZXMgZm9jdXMuICovXG4gIHZtRm9jdXMhOiBFbWl0dGVyPEpTWC5WbU11dGVDb250cm9sW1wib25WbUZvY3VzXCJdPjtcbiAgLyoqIEVtaXR0ZWQgd2hlbiB0aGUgY29udHJvbCBsb3NlcyBmb2N1cy4gKi9cbiAgdm1CbHVyITogRW1pdHRlcjxKU1guVm1NdXRlQ29udHJvbFtcIm9uVm1CbHVyXCJdPjtcblxuICBjb25zdHJ1Y3RvcihjOiBDaGFuZ2VEZXRlY3RvclJlZiwgcjogRWxlbWVudFJlZiwgcHJvdGVjdGVkIHo6IE5nWm9uZSkge1xuICAgIGRlZmluZSgndm0tbXV0ZS1jb250cm9sJywgVm1NdXRlQ29udHJvbCk7XG4gICAgZGVmaW5lKCd2bS1jb250cm9sJywgVm1Db250cm9sKTtcbiAgICBkZWZpbmUoJ3ZtLWljb24nLCBWbUljb24pO1xuICAgIGRlZmluZSgndm0tdG9vbHRpcCcsIFZtVG9vbHRpcCk7XG4gICAgYy5kZXRhY2goKTtcbiAgICB0aGlzLmVsID0gci5uYXRpdmVFbGVtZW50O1xuICAgIGluaXRPdXRwdXRzKHRoaXMsIFsndm1Gb2N1cycsICd2bUJsdXInXSlcbiAgfVxufVxuICAiXX0=